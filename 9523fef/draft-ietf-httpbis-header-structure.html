<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Structured Headers for HTTP</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script>
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 550px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 55px;
    overflow: auto;
    overscroll-behavior: contain;
  }
  ul.toc, #rfc\.toc {
    overflow: auto;
    overscroll-behavior: contain;
  }
  ul.toc li, #rfc\.toc li {
    font-size: 15px;
    line-height: 20px;
    text-indent: 0;
    padding-left: 1em;
  }
  body>ul.toc {
    top: 140px;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 16px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 36px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 18px;
  line-height: 27px%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
<link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Specifying Structured Headers" href="#rfc.section.2"><link rel="Chapter" title="3 Parsing Text into Structured Headers" href="#rfc.section.3"><link rel="Chapter" title="4 Structured Header Data Types" href="#rfc.section.4"><link rel="Chapter" title="5 IANA Considerations" href="#rfc.section.5"><link rel="Chapter" title="6 Security Considerations" href="#rfc.section.6"><link rel="Chapter" href="#rfc.section.7" title="7 References"><link rel="Appendix" title="A Changes" href="#rfc.section.A"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.1003, 2018/03/23 12:05:03, XSLT vendor: libxslt http://xmlsoft.org/XSLT/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Nottingham, M."><meta name="dcterms.creator" content="Kamp, P-H."><meta name="dcterms.identifier" content="urn:ietf:id:draft-ietf-httpbis-header-structure-latest"><meta name="dcterms.issued" content="2018-03-29"><meta name="dcterms.abstract" content="This document describes a set of data types and parsing algorithms associated with them that are intended to make it easier and safer to define and handle HTTP header fields. It is intended for use by new specifications of HTTP header fields as well as revisions of existing header field specifications when doing so does not cause interoperability issues."><meta name="description" content="This document describes a set of data types and parsing algorithms associated with them that are intended to make it easier and safer to define and handle HTTP header fields. It is intended for use by new specifications of HTTP header fields as well as revisions of existing header field specifications when doing so does not cause interoperability issues."></head><body><header><table class="header" id="rfc.headerblock"><tbody><tr><td class="left">HTTP Working Group</td><td class="right">M. Nottingham</td></tr><tr><td class="left">Internet-Draft</td><td class="right">Fastly</td></tr><tr><td class="left">Intended status: Standards Track</td><td class="right">P-H. Kamp</td></tr><tr><td class="left">Expires: September 30, 2018</td><td class="right">The Varnish Cache Project</td></tr><tr><td class="left"></td><td class="right">March 29, 2018</td></tr></tbody></table><div id="rfc.title"><h1>Structured Headers for HTTP</h1><div class="filename">draft-ietf-httpbis-header-structure-latest</div></div></header><section id="rfc.abstract"><h2><a href="#rfc.abstract">Abstract</a></h2><div id="rfc.abstract.p.1"><p>This document describes a set of data types and parsing algorithms associated with them that are intended to make it easier and safer to define and handle HTTP header fields. It is intended for use by new specifications of HTTP header fields as well as revisions of existing header field specifications when doing so does not cause interoperability issues.</p></div></section><section id="rfc.note.1" class="note"><h2><a href="#rfc.note.1">Note to Readers</a></h2><div id="rfc.note.1.p.1"><p><em>RFC EDITOR: please remove this section before publication</em></p></div><div id="rfc.note.1.p.2"><p>Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at <a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">https://lists.w3.org/Archives/Public/ietf-http-wg/</a>.</p></div><div id="rfc.note.1.p.3"><p>Working Group information can be found at <a href="https://httpwg.github.io/">https://httpwg.github.io/</a>; source code and issues list for this draft can be found at <a href="https://github.com/httpwg/http-extensions/labels/header-structure">https://github.com/httpwg/http-extensions/labels/header-structure</a>.</p></div></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on September 30, 2018.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright © 2018 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><hr class="noprint"><nav id="rfc.toc"><h2 class="np"><a href="#rfc.toc">Table of Contents</a></h2><ul class="toc"><li><a href="#rfc.section.1">1.</a>   <a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>   <a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>   <a href="#specify">Specifying Structured Headers</a></li><li><a href="#rfc.section.3">3.</a>   <a href="#text">Parsing Text into Structured Headers</a></li><li><a href="#rfc.section.4">4.</a>   <a href="#types">Structured Header Data Types</a><ul><li><a href="#rfc.section.4.1">4.1.</a>   <a href="#dictionary">Dictionaries</a></li><li><a href="#rfc.section.4.2">4.2.</a>   <a href="#list">Lists</a></li><li><a href="#rfc.section.4.3">4.3.</a>   <a href="#param">Parameterised Lists</a></li><li><a href="#rfc.section.4.4">4.4.</a>   <a href="#item">Items</a></li><li><a href="#rfc.section.4.5">4.5.</a>   <a href="#integer">Integers</a></li><li><a href="#rfc.section.4.6">4.6.</a>   <a href="#float">Floats</a></li><li><a href="#rfc.section.4.7">4.7.</a>   <a href="#string">Strings</a></li><li><a href="#rfc.section.4.8">4.8.</a>   <a href="#identifier">Identifiers</a></li><li><a href="#rfc.section.4.9">4.9.</a>   <a href="#binary">Binary Content</a></li></ul></li><li><a href="#rfc.section.5">5.</a>   <a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.6">6.</a>   <a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.7">7.</a>   <a href="#rfc.references">References</a><ul><li><a href="#rfc.section.7.1">7.1.</a>   <a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.7.2">7.2.</a>   <a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">A.</a>   <a href="#changes">Changes</a><ul><li><a href="#rfc.section.A.1">A.1.</a>   <a href="#since-draft-ietf-httpbis-header-structure-04">Since draft-ietf-httpbis-header-structure-04</a></li><li><a href="#rfc.section.A.2">A.2.</a>   <a href="#since-draft-ietf-httpbis-header-structure-03">Since draft-ietf-httpbis-header-structure-03</a></li><li><a href="#rfc.section.A.3">A.3.</a>   <a href="#since-draft-ietf-httpbis-header-structure-02">Since draft-ietf-httpbis-header-structure-02</a></li><li><a href="#rfc.section.A.4">A.4.</a>   <a href="#since-draft-ietf-httpbis-header-structure-01">Since draft-ietf-httpbis-header-structure-01</a></li><li><a href="#rfc.section.A.5">A.5.</a>   <a href="#since-draft-ietf-httpbis-header-structure-00">Since draft-ietf-httpbis-header-structure-00</a></li></ul></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></nav><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a> <a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>Specifying the syntax of new HTTP header fields is an onerous task; even with the guidance in <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 8.3.1, there are many decisions – and pitfalls – for a prospective HTTP header field author.</p></div><div id="rfc.section.1.p.2"><p>Once a header field is defined, bespoke parsers for it often need to be written, because each header has slightly different handling of what looks like common syntax.</p></div><div id="rfc.section.1.p.3"><p>This document introduces structured HTTP header field values (hereafter, Structured Headers) to address these problems. Structured Headers define a generic, abstract model for header field values, along with a concrete serialisation for expressing that model in textual HTTP headers, as used by HTTP/1 <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> and HTTP/2 <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>.</p></div><div id="rfc.section.1.p.4"><p>HTTP headers that are defined as Structured Headers use the types defined in this specification to define their syntax and basic handling rules, thereby simplifying both their definition and parsing.</p></div><div id="rfc.section.1.p.5"><p>Additionally, future versions of HTTP can define alternative serialisations of the abstract model of Structured Headers, allowing headers that use it to be transmitted more efficiently without being redefined.</p></div><div id="rfc.section.1.p.6"><p>Note that it is not a goal of this document to redefine the syntax of existing HTTP headers; the mechanisms described herein are only intended to be used with headers that explicitly opt into them.</p></div><div id="rfc.section.1.p.7"><p>To specify a header field that uses Structured Headers, see <a href="#specify" title="Specifying Structured Headers">Section 2</a>.</p></div><div id="rfc.section.1.p.8"><p><a href="#types" title="Structured Header Data Types">Section 4</a> defines a number of abstract data types that can be used in Structured Headers. Dictionaries and lists are only usable at the “top” level, while the remaining types can be specified appear at the top level or inside those structures.</p></div><div id="rfc.section.1.p.9"><p>Those abstract types can be serialised into textual headers – such as those used in HTTP/1 and HTTP/2 – using the algorithms described in <a href="#text" title="Parsing Text into Structured Headers">Section 3</a>.</p></div><section id="notational-conventions"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.1.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in BCP 14 <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a> <a href="#RFC8174"><cite title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">[RFC8174]</cite></a> when, and only when, they appear in all capitals, as shown here.</p></div><div id="rfc.section.1.1.p.2"><p>This document uses the Augmented Backus-Naur Form (ABNF) notation of <a href="#RFC5234"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a>, including the DIGIT, ALPHA and DQUOTE rules from that document. It also includes the OWS rule from <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>.</p></div></section></section><section id="specify"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#specify">Specifying Structured Headers</a></h2><div id="rfc.section.2.p.1"><p>A HTTP header that uses Structured Headers need to be defined to do so explicitly; recipients and generators need to know that the requirements of this document are in effect. The simplest way to do that is by referencing this document in its definition.</p></div><div id="rfc.section.2.p.2"><p>The field’s definition will also need to specify the field-value’s allowed syntax, in terms of the types described in <a href="#types" title="Structured Header Data Types">Section 4</a>, along with their associated semantics.</p></div><div id="rfc.section.2.p.3"><p>A header field definition cannot relax or otherwise modify the requirements of this specification; doing so would preclude handling by generic software.</p></div><div id="rfc.section.2.p.4"><p>However, header field authors are encouraged to clearly state additional constraints upon the syntax, as well as the consequences when those constraints are violated. Such additional constraints could include additional structure (e.g., a list of URLs <a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a> inside a string) that cannot be expressed using the primitives defined here.</p></div><div id="rfc.section.2.p.5" class="avoidbreakafter"><p>For example:</p></div><div id="rfc.figure.u.1"><pre class="text">
# FooExample Header

The FooExample HTTP header field conveys information about how
much Foo the message has.

FooExample is a Structured header [RFCxxxx]. Its value MUST be a
dictionary ([RFCxxxx], Section Y.Y).

The dictionary MUST contain:

* Exactly one member whose key is "foo", and whose value is an
  integer ([RFCxxxx], Section Y.Y), indicating the number of foos in
  the message.
* Exactly one member whose key is "barUrls", and whose value is a
  string ([RFCxxxx], Section Y.Y), conveying the Bar URLs for the
  message. See below for processing requirements.

If the parsed header field does not contain both, it MUST be ignored.

"foo" MUST be between 0 and 10, inclusive; other values MUST cause
the header to be ignored.

"barUrls" contains a space-separated list of URI-references
([RFC3986], Section 4.1):

   barURLs = URI-reference *( 1*SP URI-reference )

If a member of barURLs is not a valid URI-reference, it MUST cause
that value to be ignored.

If a member of barURLs is a relative reference ([RFC3986],
Section 4.2), it MUST be resolved ([RFC3986], Section 5) before being
used.
</pre></div><div id="rfc.section.2.p.6"><p>Note that empty header field values are not allowed, and therefore parsing for them will fail.</p></div></section><section id="text"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#text">Parsing Text into Structured Headers</a></h2><div id="rfc.section.3.p.1"><p>When a receiving implementation parses textual HTTP header fields (e.g., in HTTP/1 or HTTP/2) that are known to be Structured Headers, it is important that care be taken, as there are a number of edge cases that can cause interoperability or even security problems. This section specifies the algorithm for doing so.</p></div><div id="rfc.section.3.p.2"><p>Given an ASCII string input_string that represents the chosen header’s field-value, and header_type, one of “dictionary”, “list”, “param-list”, or “item”, return the parsed header value.</p></div><div id="rfc.section.3.p.3"><ol><li>Discard any leading OWS from input_string.</li><li>If header_type is “dictionary”, let output be the result of Parsing a Dictionary from Text (<a href="#parse-dictionary" title="Parsing a Dictionary from Text">Section 4.1.1</a>).</li><li>If header_type is “list”, let output be the result of Parsing a List from Text (<a href="#parse-list" title="Parsing a List from Text">Section 4.2.1</a>).</li><li>If header_type is “param-list”, let output be the result of Parsing a Parameterised List from Text (<a href="#parse-param-list" title="Parsing a Parameterised List from Text">Section 4.3.1</a>).</li><li>Otherwise, let output be the result of Parsing an Item from Text (<a href="#parse-item" title="Parsing an Item from Text">Section 4.4.1</a>).</li><li>Discard any leading OWS from input_string.</li><li>If input_string is not empty, fail parsing.</li><li>Otherwise, return output.</li></ol></div><div id="rfc.section.3.p.4"><p>When generating input_string, parsers MUST combine all instances of the target header field into one comma-separated field-value, as per <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 3.2.2; this assures that the header is processed correctly.</p></div><div id="rfc.section.3.p.5"><p>Note that in the case of lists, parameterised lists and dictionaries, this has the effect of coalescing all of the values for that field. However, for singular items, parsing will fail if more than instance of that header field is present.</p></div><div id="rfc.section.3.p.6"><p>If parsing fails – including when calling another algorithm – the entire header field’s value MUST be discarded. This is intentionally strict, to improve interoperability and safety, and specifications referencing this document cannot loosen this requirement.</p></div><div id="rfc.section.3.p.7"><p>Note that this has the effect of discarding any header field with non-ASCII characters in input_string.</p></div></section><section id="types"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#types">Structured Header Data Types</a></h2><div id="rfc.section.4.p.1"><p>This section defines the abstract value types that can be composed into Structured Headers, along with the textual HTTP serialisations of them.</p></div><section id="dictionary"><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#dictionary">Dictionaries</a></h3><div id="rfc.section.4.1.p.1"><p>Dictionaries are unordered maps of key-value pairs, where the keys are identifiers (<a href="#identifier" title="Identifiers">Section 4.8</a>) and the values are items (<a href="#item" title="Items">Section 4.4</a>). There can be from 1 to 1024 members, and keys are required to be unique.</p></div><div id="rfc.section.4.1.p.2"><p>In the textual HTTP serialisation, keys and values are separated by “=” (without whitespace), and key/value pairs are separated by a comma with optional whitespace. Duplicate keys MUST cause parsing to fail.</p></div><div id="rfc.figure.u.2"><pre class="inline">
dictionary  = dict-member 0*1023( OWS "," OWS dict-member )
dict-member = identifier "=" item
</pre></div><div id="rfc.section.4.1.p.3" class="avoidbreakafter"><p>For example, a header field whose value is defined as a dictionary could look like:</p></div><div id="rfc.figure.u.3"><pre class="text">
ExampleDictHeader: foo=1.23, en="Applepie", da=*w4ZibGV0w6ZydGUK*
</pre></div><div id="rfc.section.4.1.p.4"><p>Typically, a header field specification will define the semantics of individual keys, as well as whether their presence is required or optional. Recipients MUST ignore keys that are undefined or unknown, unless the header field’s specification specifically disallows them.</p></div><section id="parse-dictionary"><h4 id="rfc.section.4.1.1"><a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#parse-dictionary">Parsing a Dictionary from Text</a></h4><div id="rfc.section.4.1.1.p.1"><p>Given an ASCII string input_string, return a mapping of (identifier, item). input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.1.1.p.2"><ol><li>Let dictionary be an empty, unordered mapping.</li><li>While input_string is not empty: <ol><li>Let this_key be the result of running Parse Identifier from Text (<a href="#parse-identifier" title="Parsing a Identifier from Text">Section 4.8.1</a>) with input_string.</li><li>If dictionary already contains this_key, fail parsing.</li><li>Consume a “=” from input_string; if none is present, fail parsing.</li><li>Let this_value be the result of running Parse Item from Text (<a href="#parse-item" title="Parsing an Item from Text">Section 4.4.1</a>) with input_string.</li><li>Add key this_key with value this_value to dictionary.</li><li>If dictionary has more than 1024 members, fail parsing.</li><li>Discard any leading OWS from input_string.</li><li>If input_string is empty, return dictionary.</li><li>Consume a COMMA from input_string; if no comma is present, fail parsing.</li><li>Discard any leading OWS from input_string.</li><li>If input_string is empty, fail parsing.</li></ol></li><li>No structured data has been found; fail parsing.</li></ol></div></section></section><section id="list"><h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#list">Lists</a></h3><div id="rfc.section.4.2.p.1"><p>Lists are arrays of items (<a href="#item" title="Items">Section 4.4</a>) with one to 1024 members.</p></div><div id="rfc.section.4.2.p.2"><p>In the textual HTTP serialisation, each member is separated by a comma and optional whitespace.</p></div><div id="rfc.figure.u.4"><pre class="inline">
list = list-member 0*1023( OWS "," OWS list-member )
list-member = item
</pre></div><div id="rfc.section.4.2.p.3" class="avoidbreakafter"><p>For example, a header field whose value is defined as a list of strings could look like:</p></div><div id="rfc.figure.u.5"><pre class="text">
ExampleStrListHeader: "foo", "bar", "It was the best of times."
</pre></div><section id="parse-list"><h4 id="rfc.section.4.2.1"><a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#parse-list">Parsing a List from Text</a></h4><div id="rfc.section.4.2.1.p.1"><p>Given an ASCII string input_string, return a list of items. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.2.1.p.2"><ol><li>Let items be an empty array.</li><li>While input_string is not empty: <ol><li>Let item be the result of running Parse Item from Text (<a href="#parse-item" title="Parsing an Item from Text">Section 4.4.1</a>) with input_string.</li><li>Append item to items.</li><li>If items has more than 1024 members, fail parsing.</li><li>Discard any leading OWS from input_string.</li><li>If input_string is empty, return items.</li><li>Consume a COMMA from input_string; if no comma is present, fail parsing.</li><li>Discard any leading OWS from input_string.</li><li>If input_string is empty, fail parsing.</li></ol></li><li>No structured data has been found; fail parsing.</li></ol></div></section></section><section id="param"><h3 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#param">Parameterised Lists</a></h3><div id="rfc.section.4.3.p.1"><p>Parameterised Lists are arrays of a parameterised identifiers with 1 to 256 members.</p></div><div id="rfc.section.4.3.p.2"><p>A parameterised identifier is an identifier (<a href="#identifier" title="Identifiers">Section 4.8</a>) with up to 256 parameters, each parameter having a identifier and an optional value that is an item (<a href="#item" title="Items">Section 4.4</a>). Ordering between parameters is not significant, and duplicate parameters MUST cause parsing to fail.</p></div><div id="rfc.section.4.3.p.3"><p>In the textual HTTP serialisation, each parameterised identifier is separated by a comma and optional whitespace. Parameters are delimited from each other using semicolons (“;”), and equals (“=”) delimits the parameter name from its value.</p></div><div id="rfc.figure.u.6"><pre class="inline">
param-list = param-id 0*255( OWS "," OWS param-id )
param-id   = identifier 0*256( OWS ";" OWS identifier [ "=" item ] )
</pre></div><div id="rfc.section.4.3.p.4"><p>For example,</p></div><div id="rfc.figure.u.7"><pre class="text">
ExampleParamListHeader: abc_123;a=1;b=2; c, def_456, ghi;q="19";r=foo
</pre></div><section id="parse-param-list"><h4 id="rfc.section.4.3.1"><a href="#rfc.section.4.3.1">4.3.1.</a> <a href="#parse-param-list">Parsing a Parameterised List from Text</a></h4><div id="rfc.section.4.3.1.p.1"><p>Given an ASCII string input_string, return a list of parameterised identifiers. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.3.1.p.2"><ol><li>Let items be an empty array.</li><li>While input_string is not empty: <ol><li>Let item be the result of running Parse Parameterised Identifier from Text (<a href="#parse-param-id" title="Parsing a Parameterised Identifier from Text">Section 4.3.2</a>) with input_string.</li><li>Append item to items.</li><li>If items has more than 256 members, fail parsing.</li><li>Discard any leading OWS from input_string.</li><li>If input_string is empty, return items.</li><li>Consume a COMMA from input_string; if no comma is present, fail parsing.</li><li>Discard any leading OWS from input_string.</li><li>If input_string is empty, fail parsing.</li></ol></li><li>No structured data has been found; fail parsing.</li></ol></div></section><section id="parse-param-id"><h4 id="rfc.section.4.3.2"><a href="#rfc.section.4.3.2">4.3.2.</a> <a href="#parse-param-id">Parsing a Parameterised Identifier from Text</a></h4><div id="rfc.section.4.3.2.p.1"><p>Given an ASCII string input_string, return a identifier with an mapping of parameters. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.3.2.p.2"><ol><li>Let primary_identifier be the result of Parsing a Identifier from Text (<a href="#parse-identifier" title="Parsing a Identifier from Text">Section 4.8.1</a>) from input_string.</li><li>Let parameters be an empty, unordered mapping.</li><li>In a loop: <ol><li>Discard any leading OWS from input_string.</li><li>If the first character of input_string is not “;”, exit the loop.</li><li>Consume a “;” character from the beginning of input_string.</li><li>Discard any leading OWS from input_string.</li><li>let param_name be the result of Parsing a Identifier from Text (<a href="#parse-identifier" title="Parsing a Identifier from Text">Section 4.8.1</a>) from input_string.</li><li>If param_name is already present in parameters, fail parsing.</li><li>Let param_value be a null value.</li><li>If the first character of input_string is “=”: <ol><li>Consume the “=” character at the beginning of input_string.</li><li>Let param_value be the result of Parsing an Item from Text (<a href="#parse-item" title="Parsing an Item from Text">Section 4.4.1</a>) from input_string.</li></ol></li><li>If parameters has more than 255 members, fail parsing.</li><li>Insert (param_name, param_value) into parameters.</li></ol></li><li>Return the tuple (primary_identifier, parameters).</li></ol></div></section></section><section id="item"><h3 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> <a href="#item">Items</a></h3><div id="rfc.section.4.4.p.1"><p>An item is can be a integer (<a href="#integer" title="Integers">Section 4.5</a>), float (<a href="#float" title="Floats">Section 4.6</a>), string (<a href="#string" title="Strings">Section 4.7</a>), or binary content (<a href="#binary" title="Binary Content">Section 4.9</a>).</p></div><div id="rfc.figure.u.8"><pre class="inline">
item = integer / float / string / binary
</pre></div><section id="parse-item"><h4 id="rfc.section.4.4.1"><a href="#rfc.section.4.4.1">4.4.1.</a> <a href="#parse-item">Parsing an Item from Text</a></h4><div id="rfc.section.4.4.1.p.1"><p>Given an ASCII string input_string, return an item. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.4.1.p.2"><ol><li>Discard any leading OWS from input_string.</li><li>If the first character of input_string is a “-“ or a DIGIT, process input_string as a number (<a href="#parse-number" title="Parsing a Number from Text">Section 4.5.1</a>) and return the result.</li><li>If the first character of input_string is a DQUOTE, process input_string as a string (<a href="#parse-string" title="Parsing a String from Text">Section 4.7.1</a>) and return the result.</li><li>If the first character of input_string is “*”, process input_string as binary content (<a href="#parse-binary" title="Parsing Binary Content from Text">Section 4.9.1</a>) and return the result.</li><li>Otherwise, fail parsing.</li></ol></div></section></section><section id="integer"><h3 id="rfc.section.4.5"><a href="#rfc.section.4.5">4.5.</a> <a href="#integer">Integers</a></h3><div id="rfc.section.4.5.p.1"><p>Abstractly, integers have a range of −9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 inclusive (i.e., a 64-bit signed integer).</p></div><div id="rfc.figure.u.9"><pre class="inline">
integer   = ["-"] 1*19DIGIT
</pre></div><div id="rfc.section.4.5.p.2"><p>Parsers that encounter an integer outside the range defined above MUST fail parsing. Therefore, the value “9223372036854775808” would be invalid. Likewise, values that do not conform to the ABNF above are invalid, and MUST fail parsing.</p></div><div id="rfc.section.4.5.p.3" class="avoidbreakafter"><p>For example, a header whose value is defined as a integer could look like:</p></div><div id="rfc.figure.u.10"><pre class="text">
ExampleIntegerHeader: 42
</pre></div><section id="parse-number"><h4 id="rfc.section.4.5.1"><a href="#rfc.section.4.5.1">4.5.1.</a> <a href="#parse-number">Parsing a Number from Text</a></h4><div id="rfc.section.4.5.1.p.1"><p>NOTE: This algorithm parses both Integers and Floats <a href="#float" title="Floats">Section 4.6</a>, and returns the corresponding structure.</p></div><div id="rfc.section.4.5.1.p.2"><ol><li>If the first character of input_string is not “-“ or a DIGIT, fail parsing.</li><li>Let input_number be the result of consuming input_string up to (but not including) the first character that is not in DIGIT, “-“, and “.”.</li><li>If input_number contains “.”, parse it as a floating point number and let output_number be the result.</li><li>Otherwise, parse input_number as an integer and let output_number be the result.</li><li>Return output_number.</li></ol></div></section></section><section id="float"><h3 id="rfc.section.4.6"><a href="#rfc.section.4.6">4.6.</a> <a href="#float">Floats</a></h3><div id="rfc.section.4.6.p.1"><p>Abstractly, floats are integers with a fractional part. They have a maximum of fifteen digits available to be used in both of the parts, as reflected in the ABNF below; this allows them to be stored as IEEE 754 double precision numbers (binary64) (<a href="#IEEE754"><cite title="IEEE Standard for Floating-Point Arithmetic">[IEEE754]</cite></a>).</p></div><div id="rfc.section.4.6.p.2"><p>The textual HTTP serialisation of floats allows a maximum of fifteen digits between the integer and fractional part, with at least one required on each side, along with an optional “-“ indicating negative numbers.</p></div><div id="rfc.figure.u.11"><pre class="inline">
float    = ["-"] (
             DIGIT "." 1*14DIGIT /
            2DIGIT "." 1*13DIGIT /
            3DIGIT "." 1*12DIGIT /
            4DIGIT "." 1*11DIGIT /
            5DIGIT "." 1*10DIGIT /
            6DIGIT "." 1*9DIGIT /
            7DIGIT "." 1*8DIGIT /
            8DIGIT "." 1*7DIGIT /
            9DIGIT "." 1*6DIGIT /
           10DIGIT "." 1*5DIGIT /
           11DIGIT "." 1*4DIGIT /
           12DIGIT "." 1*3DIGIT /
           13DIGIT "." 1*2DIGIT /
           14DIGIT "." 1DIGIT )
</pre></div><div id="rfc.section.4.6.p.3"><p>Values that do not conform to the ABNF above are invalid, and MUST fail parsing.</p></div><div id="rfc.section.4.6.p.4" class="avoidbreakafter"><p>For example, a header whose value is defined as a float could look like:</p></div><div id="rfc.figure.u.12"><pre class="text">
ExampleFloatHeader: 4.5
</pre></div><div id="rfc.section.4.6.p.5"><p>See <a href="#parse-number" title="Parsing a Number from Text">Section 4.5.1</a> for the parsing algorithm for floats.</p></div></section><section id="string"><h3 id="rfc.section.4.7"><a href="#rfc.section.4.7">4.7.</a> <a href="#string">Strings</a></h3><div id="rfc.section.4.7.p.1"><p>Abstractly, strings are up to 1024 printable ASCII <a href="#RFC0020"><cite title="ASCII format for network interchange">[RFC0020]</cite></a> characters (i.e., the range 0x20 to 0x7E). Note that this excludes tabs, newlines, carriage returns, etc.</p></div><div id="rfc.section.4.7.p.2"><p>The textual HTTP serialisation of strings uses a backslash (“\”) to escape double quotes and backslashes in strings.</p></div><div id="rfc.figure.u.13"><pre class="inline">
string    = DQUOTE 0*1024(chr) DQUOTE
chr       = unescaped / escaped
unescaped = %x20-21 / %x23-5B / %x5D-7E
escaped   = "\" ( DQUOTE / "\" )
</pre></div><div id="rfc.section.4.7.p.3" class="avoidbreakafter"><p>For example, a header whose value is defined as a string could look like:</p></div><div id="rfc.figure.u.14"><pre class="text">
ExampleStringHeader: "hello world"
</pre></div><div id="rfc.section.4.7.p.4"><p>Note that strings only use DQUOTE as a delimiter; single quotes do not delimit strings. Furthermore, only DQUOTE and “\” can be escaped; other sequences MUST cause parsing to fail.</p></div><div id="rfc.section.4.7.p.5"><p>Unicode is not directly supported in Structured Headers, because it causes a number of interoperability issues, and – with few exceptions – header values do not require it.</p></div><div id="rfc.section.4.7.p.6"><p>When it is necessary for a field value to convey non-ASCII string content, binary content (<a href="#binary" title="Binary Content">Section 4.9</a>) SHOULD be specified, along with a character encoding (preferably, UTF-8).</p></div><section id="parse-string"><h4 id="rfc.section.4.7.1"><a href="#rfc.section.4.7.1">4.7.1.</a> <a href="#parse-string">Parsing a String from Text</a></h4><div id="rfc.section.4.7.1.p.1"><p>Given an ASCII string input_string, return an unquoted string. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.7.1.p.2"><ol><li>Let output_string be an empty string.</li><li>If the first character of input_string is not DQUOTE, fail parsing.</li><li>Discard the first character of input_string.</li><li>While input_string is not empty: <ol><li>Let char be the result of removing the first character of input_string.</li><li>If char is a backslash (“\”): <ol><li>If input_string is now empty, fail parsing.</li><li>Else: <ol><li>Let next_char be the result of removing the first character of input_string.</li><li>If next_char is not DQUOTE or “\”, fail parsing.</li><li>Append next_char to output_string.</li></ol></li></ol></li><li>Else, if char is DQUOTE, return output_string.</li><li>Else, append char to output_string.</li><li>If output_string contains more than 1024 characters, fail parsing.</li></ol></li><li>Otherwise, fail parsing.</li></ol></div></section></section><section id="identifier"><h3 id="rfc.section.4.8"><a href="#rfc.section.4.8">4.8.</a> <a href="#identifier">Identifiers</a></h3><div id="rfc.section.4.8.p.1"><p>Identifiers are short (up to 256 characters) textual identifiers; their abstract model is identical to their expression in the textual HTTP serialisation.</p></div><div id="rfc.figure.u.15"><pre class="inline">
identifier = lcalpha 0*255( lcalpha / DIGIT / "_" / "-"/ "*" / "/" )
lcalpha    = %x61-7A ; a-z
</pre></div><div id="rfc.section.4.8.p.2"><p>Note that identifiers can only contain lowercase letters.</p></div><div id="rfc.section.4.8.p.3" class="avoidbreakafter"><p>For example, a header whose value is defined as a identifier could look like:</p></div><div id="rfc.figure.u.16"><pre class="text">
ExampleIdHeader: foo/bar
</pre></div><section id="parse-identifier"><h4 id="rfc.section.4.8.1"><a href="#rfc.section.4.8.1">4.8.1.</a> <a href="#parse-identifier">Parsing a Identifier from Text</a></h4><div id="rfc.section.4.8.1.p.1"><p>Given an ASCII string input_string, return a identifier. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.8.1.p.2"><ol><li>If the first character of input_string is not lcalpha, fail parsing.</li><li>Let output_string be an empty string.</li><li>While input_string is not empty: <ol><li>Let char be the result of removing the first character of input_string.</li><li>If char is not one of lcalpha, DIGIT, “_”, “-“, “*” or “/”: <ol><li>Prepend char to input_string.</li><li>Return output_string.</li></ol></li><li>Append char to output_string.</li><li>If output_string contains more than 256 characters, fail parsing.</li></ol></li><li>Return output_string.</li></ol></div></section></section><section id="binary"><h3 id="rfc.section.4.9"><a href="#rfc.section.4.9">4.9.</a> <a href="#binary">Binary Content</a></h3><div id="rfc.section.4.9.p.1"><p>Arbitrary binary content up to 16384 bytes in size can be conveyed in Structured Headers.</p></div><div id="rfc.section.4.9.p.2"><p>The textual HTTP serialisation encodes the data using Base 64 Encoding <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 4, and surrounds it with a pair of asterisks (“*”) to delimit from other content.</p></div><div id="rfc.section.4.9.p.3"><p>The encoded data is required to be padded with “=”, as per <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 3.2. It is RECOMMENDED that parsers reject encoded data that is not properly padded, although this might not be possible with some base64 implementations.</p></div><div id="rfc.section.4.9.p.4"><p>Likewise, encoded data is required to have pad bits set to zero, as per <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 3.5. It is RECOMMENDED that parsers fail on encoded data that has non-zero pad bits, although this might not be possible with some base64 implementations.</p></div><div id="rfc.section.4.9.p.5"><p>This specification does not relax the requirements in <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>, Section 3.1 and 3.3; therefore, parsers MUST fail on characters outside the base64 alphabet, and on line feeds in encoded data.</p></div><div id="rfc.figure.u.17"><pre class="inline">
binary = "*" 0*21846(base64) "*"
base64 = ALPHA / DIGIT / "+" / "/" / "="
</pre></div><div id="rfc.section.4.9.p.6" class="avoidbreakafter"><p>For example, a header whose value is defined as binary content could look like:</p></div><div id="rfc.figure.u.18"><pre class="text">
ExampleBinaryHeader: *cHJldGVuZCB0aGlzIGlzIGJpbmFyeSBjb250ZW50Lg==*
</pre></div><section id="parse-binary"><h4 id="rfc.section.4.9.1"><a href="#rfc.section.4.9.1">4.9.1.</a> <a href="#parse-binary">Parsing Binary Content from Text</a></h4><div id="rfc.section.4.9.1.p.1"><p>Given an ASCII string input_string, return binary content. input_string is modified to remove the parsed value.</p></div><div id="rfc.section.4.9.1.p.2"><ol><li>If the first character of input_string is not “*”, fail parsing.</li><li>Discard the first character of input_string.</li><li>Let b64_content be the result of removing content of input_string up to but not including the first instance of the character “*”. If there is not a “*” character before the end of input_string, fail parsing.</li><li>Consume the “*” character at the beginning of input_string.</li><li>If b64_content is has more than 21846 characters, fail parsing.</li><li>Let binary_content be the result of Base 64 Decoding <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a> b64_content, synthesising padding if necessary (note the requirements about recipient behaviour in <a href="#binary" title="Binary Content">Section 4.9</a>).</li><li>Return binary_content.</li></ol></div></section></section></section><section id="iana-considerations"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.5.p.1"><p>This draft has no actions for IANA.</p></div></section><section id="security-considerations"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.6.p.1"><p>TBD</p></div></section><section id="rfc.references"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a> References</h2><section><div id="rfc.references.1"><h3 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> Normative References</h3><dl class="reference"><dt id="RFC0020">[RFC0020]</dt><dd>Cerf, V., “<a href="https://tools.ietf.org/html/rfc20">ASCII format for network interchange</a>”, STD 80, RFC 20, <a href="http://dx.doi.org/10.17487/RFC0020">DOI 10.17487/RFC0020</a>, October 1969, &lt;<a href="https://www.rfc-editor.org/info/rfc20">https://www.rfc-editor.org/info/rfc20</a>&gt;.</dd><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP 14, RFC 2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI 10.17487/RFC2119</a>, March 1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC4648">[RFC4648]</dt><dd>Josefsson, S., “<a href="https://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>”, RFC 4648, <a href="http://dx.doi.org/10.17487/RFC4648">DOI 10.17487/RFC4648</a>, October 2006, &lt;<a href="https://www.rfc-editor.org/info/rfc4648">https://www.rfc-editor.org/info/rfc4648</a>&gt;.</dd><dt id="RFC5234">[RFC5234]</dt><dd>Crocker, D., Ed. and P. Overell, “<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>”, STD 68, RFC 5234, <a href="http://dx.doi.org/10.17487/RFC5234">DOI 10.17487/RFC5234</a>, January 2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5234">https://www.rfc-editor.org/info/rfc5234</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC 7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI 10.17487/RFC7230</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC8174">[RFC8174]</dt><dd>Leiba, B., “<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>”, BCP 14, RFC 8174, <a href="http://dx.doi.org/10.17487/RFC8174">DOI 10.17487/RFC8174</a>, May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.</dd></dl></div></section><section><div id="rfc.references.2"><h3 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> Informative References</h3><dl class="reference"><dt id="IEEE754">[IEEE754]</dt><dd>IEEE, “<a href="http://ieeexplore.ieee.org/document/4610935/">IEEE Standard for Floating-Point Arithmetic</a>”, IEEE 754-2008, <a href="http://dx.doi.org/10.1109/IEEESTD.2008.4610935">DOI 10.1109/IEEESTD.2008.4610935</a>, <a href="https://www.worldcat.org/search?q=isbn:9780738157528">ISBN 978-0-7381-5752-8</a>, August 2008, &lt;<a href="http://ieeexplore.ieee.org/document/4610935/">http://ieeexplore.ieee.org/document/4610935/</a>&gt;.<br>See also <a href="http://grouper.ieee.org/groups/754/">http://grouper.ieee.org/groups/754/</a>.</dd><dt id="RFC3986">[RFC3986]</dt><dd>Berners-Lee, T., Fielding, R., and L. Masinter, “<a href="https://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>”, STD 66, RFC 3986, <a href="http://dx.doi.org/10.17487/RFC3986">DOI 10.17487/RFC3986</a>, January 2005, &lt;<a href="https://www.rfc-editor.org/info/rfc3986">https://www.rfc-editor.org/info/rfc3986</a>&gt;.</dd><dt id="RFC7231">[RFC7231]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, RFC 7231, <a href="http://dx.doi.org/10.17487/RFC7231">DOI 10.17487/RFC7231</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7231">https://www.rfc-editor.org/info/rfc7231</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC 7540, <a href="http://dx.doi.org/10.17487/RFC7540">DOI 10.17487/RFC7540</a>, May 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7540">https://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd></dl></div></section></section><section id="changes"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a> <a href="#changes">Changes</a></h2><section id="since-draft-ietf-httpbis-header-structure-04"><h3 id="rfc.section.A.1"><a href="#rfc.section.A.1">A.1.</a> <a href="#since-draft-ietf-httpbis-header-structure-04">Since draft-ietf-httpbis-header-structure-04</a></h3><div id="rfc.section.A.1.p.1"><ul><li>Remove identifiers from item.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-03"><h3 id="rfc.section.A.2"><a href="#rfc.section.A.2">A.2.</a> <a href="#since-draft-ietf-httpbis-header-structure-03">Since draft-ietf-httpbis-header-structure-03</a></h3><div id="rfc.section.A.2.p.1"><ul><li>Strengthen language around failure handling.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-02"><h3 id="rfc.section.A.3"><a href="#rfc.section.A.3">A.3.</a> <a href="#since-draft-ietf-httpbis-header-structure-02">Since draft-ietf-httpbis-header-structure-02</a></h3><div id="rfc.section.A.3.p.1"><ul><li>Split Numbers into Integers and Floats.</li><li>Define number parsing.</li><li>Tighten up binary parsing and give it an explicit end delimiter.</li><li>Clarify that mappings are unordered.</li><li>Allow zero-length strings.</li><li>Improve string parsing algorithm.</li><li>Improve limits in algorithms.</li><li>Require parsers to combine header fields before processing.</li><li>Throw an error on trailing garbage.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-01"><h3 id="rfc.section.A.4"><a href="#rfc.section.A.4">A.4.</a> <a href="#since-draft-ietf-httpbis-header-structure-01">Since draft-ietf-httpbis-header-structure-01</a></h3><div id="rfc.section.A.4.p.1"><ul><li>Replaced with draft-nottingham-structured-headers.</li></ul></div></section><section id="since-draft-ietf-httpbis-header-structure-00"><h3 id="rfc.section.A.5"><a href="#rfc.section.A.5">A.5.</a> <a href="#since-draft-ietf-httpbis-header-structure-00">Since draft-ietf-httpbis-header-structure-00</a></h3><div id="rfc.section.A.5.p.1"><ul><li>Added signed 64bit integer type.</li><li>Drop UTF8, and settle on BCP137 ::EmbeddedUnicodeChar for h1-unicode-string.</li><li>Change h1_blob delimiter to “:” since “’” is valid t_char</li></ul></div></section></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Authors' Addresses</a></h2><address><b>Mark Nottingham</b><br>Fastly<br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="https://www.mnot.net/">https://www.mnot.net/</a></address><address><b>Poul-Henning Kamp</b><br>The Varnish Cache Project<br>EMail: <a href="mailto:phk@varnish-cache.org">phk@varnish-cache.org</a></address></section></body></html>
