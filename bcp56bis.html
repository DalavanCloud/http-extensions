<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>On the use of HTTP as a Substrate</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script>
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 550px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 55px;
    overflow: auto;
    overscroll-behavior: contain;
  }
  ul.toc, #rfc\.toc {
    overflow: auto;
    overscroll-behavior: contain;
  }
  ul.toc li, #rfc\.toc li {
    font-size: 15px;
    line-height: 20px;
    text-indent: 0;
    padding-left: 1em;
  }
  body>ul.toc {
    top: 140px;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 16px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 36px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 18px;
  line-height: 27px%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
<link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Is HTTP Being Used?" href="#rfc.section.2"><link rel="Chapter" title="3 What’s Important About HTTP" href="#rfc.section.3"><link rel="Chapter" title="4 Best Practices for Using HTTP" href="#rfc.section.4"><link rel="Chapter" title="5 IANA Considerations" href="#rfc.section.5"><link rel="Chapter" title="6 Security Considerations" href="#rfc.section.6"><link rel="Chapter" href="#rfc.section.7" title="7 References"><link rel="Appendix" title="A Changes from RFC 3205" href="#rfc.section.A"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.1003, 2018/03/23 12:05:03, XSLT vendor: libxslt http://xmlsoft.org/XSLT/"><meta name="keywords" content="substrate"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Nottingham, M."><meta name="dcterms.identifier" content="urn:ietf:id:draft-ietf-httpbis-bcp56bis-latest"><meta name="dcterms.issued" content="2018-03-30"><meta name="dct.replaces" content="urn:ietf:rfc:3205"><meta name="dcterms.abstract" content="HTTP is often used as a substrate for other application protocols. This document specifies best practices for these protocols’ use of HTTP.This document obsoletes RFC 3205."><meta name="description" content="HTTP is often used as a substrate for other application protocols. This document specifies best practices for these protocols’ use of HTTP.This document obsoletes RFC 3205."></head><body><header><table class="header" id="rfc.headerblock"><tbody><tr><td class="left">HTTP Working Group</td><td class="right">M. Nottingham</td></tr><tr><td class="left">Internet-Draft</td><td class="right">March 30, 2018</td></tr><tr><td class="left">Obsoletes: <a href="https://tools.ietf.org/html/rfc3205">3205</a> (if approved)</td><td class="right"></td></tr><tr><td class="left">Intended status: Best Current Practice</td><td class="right"></td></tr><tr><td class="left">Expires: October 1, 2018</td><td class="right"></td></tr></tbody></table><div id="rfc.title"><h1>On the use of HTTP as a Substrate</h1><div class="filename">draft-ietf-httpbis-bcp56bis-latest</div></div></header><section id="rfc.abstract"><h2><a href="#rfc.abstract">Abstract</a></h2><div id="rfc.abstract.p.1"><p>HTTP is often used as a substrate for other application protocols. This document specifies best practices for these protocols’ use of HTTP.</p></div><div id="rfc.abstract.p.2"><p>This document obsoletes RFC 3205.</p></div></section><section id="rfc.note.1" class="note"><h2><a href="#rfc.note.1">Note to Readers </a></h2><div id="rfc.note.1.p.1"><p>Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at <a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">https://lists.w3.org/Archives/Public/ietf-http-wg/</a>.</p></div><div id="rfc.note.1.p.2"><p>Working Group information can be found at <a href="http://httpwg.github.io/">http://httpwg.github.io/</a>; source code and issues list for this draft can be found at <a href="https://github.com/httpwg/http-extensions/labels/bcp56bis">https://github.com/httpwg/http-extensions/labels/bcp56bis</a>.</p></div></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on October 1, 2018.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright © 2018 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><hr class="noprint"><nav id="rfc.toc"><h2 class="np"><a href="#rfc.toc">Table of Contents</a></h2><ul class="toc"><li><a href="#rfc.section.1">1.</a>   <a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>   <a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>   <a href="#used">Is HTTP Being Used?</a></li><li><a href="#rfc.section.3">3.</a>   <a href="#overview">What’s Important About HTTP</a><ul><li><a href="#rfc.section.3.1">3.1.</a>   <a href="#generic-semantics">Generic Semantics</a></li><li><a href="#rfc.section.3.2">3.2.</a>   <a href="#links">Links</a></li><li><a href="#rfc.section.3.3">3.3.</a>   <a href="#getting-value-from-http">Getting Value from HTTP</a></li></ul></li><li><a href="#rfc.section.4">4.</a>   <a href="#bp">Best Practices for Using HTTP</a><ul><li><a href="#rfc.section.4.1">4.1.</a>   <a href="#specifying-the-use-of-http">Specifying the Use of HTTP</a></li><li><a href="#rfc.section.4.2">4.2.</a>   <a href="#resource">Defining HTTP Resources</a></li><li><a href="#rfc.section.4.3">4.3.</a>   <a href="#clients">Specifying Client Behaviours</a></li><li><a href="#rfc.section.4.4">4.4.</a>   <a href="#http-urls">HTTP URLs</a><ul><li><a href="#rfc.section.4.4.1">4.4.1.</a>   <a href="#initial-url-discovery">Initial URL Discovery</a></li><li><a href="#rfc.section.4.4.2">4.4.2.</a>   <a href="#scheme">URL Schemes</a></li><li><a href="#rfc.section.4.4.3">4.4.3.</a>   <a href="#transport-ports">Transport Ports</a></li></ul></li><li><a href="#rfc.section.4.5">4.5.</a>   <a href="#http-methods">HTTP Methods</a></li><li><a href="#rfc.section.4.6">4.6.</a>   <a href="#http-status-codes">HTTP Status Codes</a></li><li><a href="#rfc.section.4.7">4.7.</a>   <a href="#headers">HTTP Header Fields</a></li><li><a href="#rfc.section.4.8">4.8.</a>   <a href="#payload">Defining Message Payloads</a></li><li><a href="#rfc.section.4.9">4.9.</a>   <a href="#state">Authentication and Application State</a></li><li><a href="#rfc.section.4.10">4.10.</a>   <a href="#browser">Co-Existing with Web Browsing</a></li><li><a href="#rfc.section.4.11">4.11.</a>   <a href="#other-apps">Co-Existing with Other Applications</a></li></ul></li><li><a href="#rfc.section.5">5.</a>   <a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.6">6.</a>   <a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.7">7.</a>   <a href="#rfc.references">References</a><ul><li><a href="#rfc.section.7.1">7.1.</a>   <a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.7.2">7.2.</a>   <a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">A.</a>   <a href="#changes-from-rfc-3205">Changes from RFC 3205</a></li><li><a href="#rfc.authors">Author's Address</a></li></ul></nav><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a> <a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1" class="avoidbreakafter"><p>HTTP <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> is often used as a substrate for other application protocols. This is done for a variety of reasons, including:</p></div><div id="rfc.section.1.p.2"><ul><li>familiarity by implementers, specifiers, administrators, developers and users,</li><li>availability of a variety of client, server and proxy implementations,</li><li>ease of use,</li><li>ubiquity of Web browsers,</li><li>reuse of existing mechanisms like authentication and encryption,</li><li>presence of HTTP servers and clients in target deployments, and</li><li>its ability to traverse firewalls.</li></ul></div><div id="rfc.section.1.p.3"><p>In many cases, these protocols are ad hoc; they are intended for only deployment on the server side, and consumption by a limited set of clients. A body of practices and tools has arisen around defining such “HTTP APIs” that favours these conditions.</p></div><div id="rfc.section.1.p.4"><p>However, when such a protocol is standarised, it is typically deployed on multiple servers, implemented a number of times, and might be consumed by a broader variety of clients. Such diversity brings a different set of concerns, and tools and practices intended for a single-server deployment might not be suitable.</p></div><div id="rfc.section.1.p.5"><p>In particular, standards-defined HTTP APIs need to more carefully consider how extensibility and evolution will be handled, how different deployment requirements will be accommodated, and how clients will evolve with the API.</p></div><div id="rfc.section.1.p.6" class="avoidbreakafter"><p>At the same time, the Internet community has a tradition of protocol reuse (e.g., Telnet <a href="#RFC0854"><cite title="Telnet Protocol Specification">[RFC0854]</cite></a> as a substrate for FTP <a href="#RFC0959"><cite title="File Transfer Protocol">[RFC0959]</cite></a> and SMTP <a href="#RFC2821"><cite title="Simple Mail Transfer Protocol">[RFC2821]</cite></a>), but less experience using HTTP as a substrate. Because HTTP is extensible in many ways, a number of questions arise, such as:</p></div><div id="rfc.section.1.p.7"><ul><li>Should an application using HTTP define a new URL scheme? Use new ports?</li><li>Should it use standard HTTP methods and status codes, or define new ones?</li><li>How can the maximum value be extracted from the use of HTTP?</li><li>How does it coexist with other uses of HTTP – especially Web browsing?</li><li>How can interoperability problems and “protocol dead ends” be avoided?</li></ul></div><div id="rfc.section.1.p.8"><p>This document contains best current practices regarding the use of HTTP by applications other than Web browsing. <a href="#used" title="Is HTTP Being Used?">Section 2</a> defines what applications it applies to; <a href="#overview" title="What’s Important About HTTP">Section 3</a> surveys the properties of HTTP that are important to preserve, and <a href="#bp" title="Best Practices for Using HTTP">Section 4</a> conveys best practices for those applications that do use HTTP.</p></div><div id="rfc.section.1.p.9"><p>It is written primarily to guide IETF efforts to define application protocols using HTTP for deployment on the Internet, but might be applicable in other situations. Note that the requirements herein do not necessarily apply to the development of generic HTTP extensions.</p></div><section id="notational-conventions"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.1.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in BCP 14 <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a> <a href="#RFC8174"><cite title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">[RFC8174]</cite></a> when, and only when, they appear in all capitals, as shown here.</p></div></section></section><section id="used"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#used">Is HTTP Being Used?</a></h2><div id="rfc.section.2.p.1" class="avoidbreakafter"><p>Different applications have different goals when using HTTP. In this document, we say an application is <em>using HTTP</em> when any of the following conditions are true:</p></div><div id="rfc.section.2.p.2"><ul><li>The transport port in use is 80 or 443,</li><li>The URL scheme “http” or “https” is used,</li><li>The ALPN protocol ID <a href="#RFC7301"><cite title="Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension">[RFC7301]</cite></a> generically identifies HTTP (e.g., “http/1.1”, “h2”, “h2c”), or</li><li>The IANA registries defined for HTTP are updated or modified.</li></ul></div><div id="rfc.section.2.p.3"><p>When an application is using HTTP, all of the requirements of the HTTP protocol suite (including but not limited to <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, <a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a>, <a href="#RFC7233"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Range Requests">[RFC7233]</cite></a>, <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, <a href="#RFC7235"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Authentication">[RFC7235]</cite></a> and <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>) are in force.</p></div><div id="rfc.section.2.p.4"><p>An application might not be <em>using HTTP</em> according to this definition, but still relying upon the HTTP specifications in some manner. For example, an application might wish to avoid re-specifying parts of the message format, but change others; or, it might want to use a different set of methods.</p></div><div id="rfc.section.2.p.5"><p>Such applications are referred to as <em>protocols based upon HTTP</em> in this document. These have more freedom to modify protocol operation, but are also likely to lose at least a portion of the benefits outlined above, as most HTTP implementations won’t be easily adaptable to these changes, and as the protocol diverges from HTTP, the benefit of mindshare will be lost.</p></div><div id="rfc.section.2.p.6"><p>Protocols that are based upon HTTP MUST NOT reuse HTTP’s URL schemes, transport ports, ALPN protocol IDs or IANA registries; rather, they are encouraged to establish their own.</p></div></section><section id="overview"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#overview">What’s Important About HTTP</a></h2><div id="rfc.section.3.p.1"><p>There are many ways that applications using HTTP are defined and deployed, and sometimes they are brought to the IETF for standardisation. In that process, what might be workable for deployment in a limited fashion isn’t appropriate for standardisation and the corresponding broader deployment.</p></div><div id="rfc.section.3.p.2"><p>This section examines the facets of the protocol that are important to preserve in these situations.</p></div><section id="generic-semantics"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#generic-semantics">Generic Semantics</a></h3><div id="rfc.section.3.1.p.1"><p>When writing an application’s specification, it’s often tempting to specify exactly how HTTP is to be implemented, supported and used.</p></div><div id="rfc.section.3.1.p.2" class="avoidbreakafter"><p>However, this can easily lead to an unintended profile of HTTP’s behaviour. For example, it’s common to see specifications with language like this:</p></div><div id="rfc.figure.u.1"><pre>
A `200 OK` response means that the widget has successfully been
updated.
</pre></div><div id="rfc.section.3.1.p.3"><p>This sort of specification is bad practice, because it is adding new semantics to HTTP’s status codes and methods, respectively; a recipient – whether it’s an origin server, client library, intermediary or cache – now has to know these extra semantics to understand the message.</p></div><div id="rfc.section.3.1.p.4" class="avoidbreakafter"><p>Some applications even require specific behaviours, such as:</p></div><div id="rfc.figure.u.2"><pre>
A `POST` request MUST result in a `201 Created` response.
</pre></div><div id="rfc.section.3.1.p.5"><p>This forms an expectation in the client that the response will always be <span class="tt">201 Created</span>, when in fact there are a number of reasons why the status code might differ in a real deployment. If the client does not anticipate this, the application’s deployment is brittle.</p></div><div id="rfc.section.3.1.p.6"><p>Much of the value of HTTP is in its <em>generic semantics</em> – that is, the protocol elements defined by HTTP are potentially applicable to every resource, not specific to a particular context. Application-specific semantics are expressed in the payload; mostly, in the body, but also in header fields.</p></div><div id="rfc.section.3.1.p.7"><p>This allows a HTTP message to be examined by generic HTTP software (e.g., HTTP servers, intermediaries, client implementations), and its handling to be correctly determined. It also allows people to leverage their knowledge of HTTP semantics without special-casing them for a particular application.</p></div><div id="rfc.section.3.1.p.8"><p>Therefore, applications that use HTTP MUST NOT re-define, refine or overlay the semantics of defined protocol elements. Instead, they SHOULD focus their specifications on protocol elements that are specific to that application; namely their HTTP resources.</p></div><div id="rfc.section.3.1.p.9"><p>See <a href="#resource" title="Defining HTTP Resources">Section 4.2</a> for details.</p></div></section><section id="links"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#links">Links</a></h3><div id="rfc.section.3.2.p.1"><p>Another common practice is assuming that the HTTP server’s name space (or a portion thereof) is exclusively for the use of a single application. This effectively overlays special, application-specific semantics onto that space, precludes other applications from using it.</p></div><div id="rfc.section.3.2.p.2"><p>As explained in <a href="#RFC7320"><cite title="URI Design and Ownership">[RFC7320]</cite></a>, such “squatting” on a part of the URL space by a standard usurps the server’s authority over its own resources, can cause deployment issues, and is therefore bad practice in standards.</p></div><div id="rfc.section.3.2.p.3"><p>Instead of statically defining URL components like paths, it is RECOMMENDED that applications using HTTP define links in payloads, to allow flexibility in deployment.</p></div><div id="rfc.section.3.2.p.4"><p>Using runtime links in this fashion has a number of other benefits. For example, navigating with a link allows a request to be routed to a different server without the overhead of a redirection, thereby supporting deployment across machines well. It becomes possible to “mix” different applications on the same server, and offers a natural path for extensibility, versioning and capability management.</p></div></section><section id="getting-value-from-http"><h3 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#getting-value-from-http">Getting Value from HTTP</a></h3><div id="rfc.section.3.3.p.1"><p>The simplest possible use of HTTP is to POST data to a single URL, thereby effectively tunnelling through the protocol.</p></div><div id="rfc.section.3.3.p.2" class="avoidbreakafter"><p>This “RPC” style of communication does get some benefit from using HTTP – namely, message framing and the availability of implementations – but fails to realise many others when used exclusively:</p></div><div id="rfc.section.3.3.p.3"><ul><li>Caching for server scalability, latency and bandwidth reduction, and reliability;</li><li>Granularity of access control (through use of a rich space of URLs);</li><li>Partial content to selectively request part of a response;</li><li>Definition of an information space using URLs; and</li><li>The ability to interact with the application easily using a Web browser.</li></ul></div><div id="rfc.section.3.3.p.4"><p>Using such a high-level protocol to tunnel simple semantics has downsides too; because of its more advanced capabilities, breadth of deployment and age, HTTP’s complexity can cause interoperability problems that could be avoided by using a simpler substrate (e.g., WebSockets <a href="#RFC6455"><cite title="The WebSocket Protocol">[RFC6455]</cite></a>, if browser support is necessary, or TCP <a href="#RFC0793"><cite title="Transmission Control Protocol">[RFC0793]</cite></a> if not), or making the application be <em>based upon HTTP</em>, instead of using it (as defined in <a href="#used" title="Is HTTP Being Used?">Section 2</a>).</p></div><div id="rfc.section.3.3.p.5"><p>Applications that use HTTP are encouraged to accommodate the various features that the protocol offers, so that their users receive the maximum benefit from it. This document does not require specific features to be used, since the appropriate design tradeoffs are highly specific to a given situation. However, following the practices in <a href="#bp" title="Best Practices for Using HTTP">Section 4</a> will help make them available.</p></div></section></section><section id="bp"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#bp">Best Practices for Using HTTP</a></h2><div id="rfc.section.4.p.1"><p>This section contains best practices regarding the use of HTTP by applications, including practices for specific HTTP protocol elements.</p></div><section id="specifying-the-use-of-http"><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#specifying-the-use-of-http">Specifying the Use of HTTP</a></h3><div id="rfc.section.4.1.p.1"><p>When specifying the use of HTTP, an application SHOULD use <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> as the primary reference; it is not necessary to reference all of the specifications in the HTTP suite unless there are specific reasons to do so (e.g., a particular feature is called out).</p></div><div id="rfc.section.4.1.p.2"><p>Applications using HTTP MAY specify a minimum version to be supported (HTTP/1.1 is suggested), and MUST NOT specify a maximum version.</p></div><div id="rfc.section.4.1.p.3"><p>Likewise, applications need not specify what HTTP mechanisms – such as redirection, caching, authentication, proxy authentication, and so on – are to be supported. Full featured support for HTTP SHOULD be taken for granted in servers and clients, and the application’s function SHOULD degrade gracefully if they are not (although this might be achieved by informing the user that their task cannot be completed).</p></div><div id="rfc.section.4.1.p.4" class="avoidbreakafter"><p>For example, an application can specify that it uses HTTP like this:</p></div><div id="rfc.figure.u.3"><pre>
Foo Application uses HTTP {{RFC7230}}. Implementations MUST support
HTTP/1.1, and MAY support later versions. Support for common HTTP
mechanisms such as redirection and caching are assumed.
</pre></div><div id="rfc.section.4.1.p.5" class="avoidbreakafter"><p>When specifying examples of protocol interactions, applications SHOULD document both the request and response messages, with full headers, preferably in HTTP/1.1 format. For example:</p></div><div id="rfc.figure.u.4"><pre>
GET /thing HTTP/1.1
Host: example.com
Accept: application/things+json
User-Agent: Foo/1.0

HTTP/1.1 200 OK
Content-Type: application/things+json
Content-Length: 500
Server: Bar/2.2

[payload here]
</pre></div></section><section id="resource"><h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#resource">Defining HTTP Resources</a></h3><div id="rfc.section.4.2.p.1" class="avoidbreakafter"><p>HTTP Applications SHOULD focus on defining the following application-specific protocol elements:</p></div><div id="rfc.section.4.2.p.2"><ul><li>Media types <a href="#RFC6838"><cite title="Media Type Specifications and Registration Procedures">[RFC6838]</cite></a>, often based upon a format convention such as JSON <a href="#RFC8259"><cite title="The JavaScript Object Notation (JSON) Data Interchange Format">[RFC8259]</cite></a>,</li><li>HTTP header fields, as per <a href="#headers" title="HTTP Header Fields">Section 4.7</a>, and</li><li>The behaviour of resources, as identified by link relations <a href="#RFC8288"><cite title="Web Linking">[RFC8288]</cite></a>.</li></ul></div><div id="rfc.section.4.2.p.3" class="avoidbreakafter"><p>By composing these protocol elements, an application can define a set of resources, identified by link relations, that implement specified behaviours, including:</p></div><div id="rfc.section.4.2.p.4"><ul><li>Retrieval of their state using GET, in one or more formats identified by media type;</li><li>Resource creation or update using POST or PUT, with an appropriately identified request body format;</li><li>Data processing using POST and identified request and response body format(s); and</li><li>Resource deletion using DELETE.</li></ul></div><div id="rfc.section.4.2.p.5" class="avoidbreakafter"><p>For example, an application might specify:</p></div><div id="rfc.figure.u.5"><pre>
Resources linked to with the "example-widget" link relation type are
Widgets. The state of a Widget can be fetched in the
"application/example-widget+json" format, and can be updated by PUT
to the same link. Widget resources can be deleted.

The "Example-Count" response header field on Widget representations
indicates how many Widgets are held by the sender.

The "application/example-widget+json" format is a JSON {{RFC8259}}
format representing the state of a Widget. It contains links to
related information in the link indicated by the Link header field
value with the "example-other-info" link relation type.
</pre></div></section><section id="clients"><h3 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#clients">Specifying Client Behaviours</a></h3><div id="rfc.section.4.3.p.1"><p>HTTP does not mandate some behaviours that have nevertheless become very common; if these are not explicitly specified by applications using HTTP, there may be confusing or interoperability problems. This section lists common examples of this, and recommends default handling for them.</p></div><div id="rfc.section.4.3.p.2"><ul><li>Redirect handling - applications using HTTP SHOULD specify that 3xx redirect status codes be followed automatically. See <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 6.4.</li><li>Redirect methods - applications using HTTP SHOULD specify that 301 and 302 redirect status codes rewrite the POST method to GET. See <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 6.4.</li><li>Cookies - Applications using HTTP MUST explicitly reference the Cookie specification <a href="#RFC6265"><cite title="HTTP State Management Mechanism">[RFC6265]</cite></a> if they are required.</li><li>Certificates - Applications using HTTP MUST specify that TLS certificates are to be checked according to <a href="#RFC2818"><cite title="HTTP Over TLS">[RFC2818]</cite></a> when HTTPS is used.</li></ul></div><div id="rfc.section.4.3.p.3"><p>In general, applications using HTTP SHOULD align their usage as closely as possible with Web browsers, to avoid interoperability issues when they are used. See <a href="#browser" title="Co-Existing with Web Browsing">Section 4.10</a>.</p></div><div id="rfc.section.4.3.p.4"><p>Applications using HTTP MUST NOT require HTTP features that are usually negotiated to be supported. For example, requiring that clients support responses with a certain content-encoding (<a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 3.1.2.2) instead of negotiating for it (<a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 5.3.4) means that otherwise conformant clients cannot interoperate with the application. Applications MAY encourage the implementation of such features, though.</p></div></section><section id="http-urls"><h3 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> <a href="#http-urls">HTTP URLs</a></h3><div id="rfc.section.4.4.p.1"><p>In HTTP, URLs are opaque identifiers under the control of the server. As outlined in <a href="#RFC7320"><cite title="URI Design and Ownership">[RFC7320]</cite></a>, standards cannot usurp this space, since it might conflict with existing resources, and constrain implementation and deployment.</p></div><div id="rfc.section.4.4.p.2"><p>In other words, applications that use HTTP MUST NOT associate application semantics with specific URL paths on arbitrary servers. Doing so inappropriately conflates the identity of the resource (its URL) with the capabilities that resource supports, bringing about many of the same interoperability problems that <a href="#RFC4367"><cite title="What's in a Name: False Assumptions about DNS Names">[RFC4367]</cite></a> warns of.</p></div><div id="rfc.section.4.4.p.3"><p>For example, specifying that a “GET to the URL /foo retrieves a bar document” is bad practice. Likewise, specifying “The widget API is at the path /bar” violates <a href="#RFC7320"><cite title="URI Design and Ownership">[RFC7320]</cite></a>.</p></div><div id="rfc.section.4.4.p.4"><p>Instead, applications that use HTTP are encouraged to ensure that URLs are discovered at runtime, allowing HTTP-based services to describe their own capabilities. One way to do this is to use typed links <a href="#RFC8288"><cite title="Web Linking">[RFC8288]</cite></a> to convey the URIs that are in use, as well as the semantics of the resources that they identify. See <a href="#resource" title="Defining HTTP Resources">Section 4.2</a> for details.</p></div><section id="initial-url-discovery"><h4 id="rfc.section.4.4.1"><a href="#rfc.section.4.4.1">4.4.1.</a> <a href="#initial-url-discovery">Initial URL Discovery</a></h4><div id="rfc.section.4.4.1.p.1"><p>Generally, a client will begin interacting with a given application server by requesting an initial document that contains information about that particular deployment, potentially including links to other relevant resources.</p></div><div id="rfc.section.4.4.1.p.2"><p>Applications that use HTTP SHOULD allow an arbitrary URL to be used as that entry point. For example, rather than specifying “the initial document is at “/foo/v1”, they should allow a deployment to use any URL as the entry point for the application.</p></div><div id="rfc.section.4.4.1.p.3"><p>In cases where doing so is impractical (e.g., it is not possible to convey a whole URL, but only a hostname) standard applications that use HTTP can request a well-known URL <a href="#RFC5785"><cite title="Defining Well-Known Uniform Resource Identifiers (URIs)">[RFC5785]</cite></a> as an entry point.</p></div></section><section id="scheme"><h4 id="rfc.section.4.4.2"><a href="#rfc.section.4.4.2">4.4.2.</a> <a href="#scheme">URL Schemes</a></h4><div id="rfc.section.4.4.2.p.1"><p>Applications that use HTTP will typically use the “http” and/or “https” URL schemes. “https” is preferred to provide authentication, integrity and confidentiality, as well as mitigate pervasive monitoring attacks <a href="#RFC7258"><cite title="Pervasive Monitoring Is an Attack">[RFC7258]</cite></a>.</p></div><div id="rfc.section.4.4.2.p.2"><p>However, application-specific schemes can be defined as well.</p></div><div id="rfc.section.4.4.2.p.3" class="avoidbreakafter"><p>When defining an URL scheme for an application using HTTP, there are a number of tradeoffs and caveats to keep in mind:</p></div><div id="rfc.section.4.4.2.p.4"><ul><li>Unmodified Web browsers will not support the new scheme. While it is possible to register new URL schemes with Web browsers (e.g. registerProtocolHandler() in <a href="#HTML5"><cite title="HTML - Living Standard">[HTML5]</cite></a>, as well as several proprietary approaches), support for these mechanisms is not shared by all browsers, and their capabilities vary.</li><li>Existing non-browser clients, intermediaries, servers and associated software will not recognise the new scheme. For example, a client library might fail to dispatch the request; a cache might refuse to store the response, and a proxy might fail to forward the request.</li><li>Because URLs occur in and are generated in HTTP artefacts commonly, often without human intervention (e.g., in the <span class="tt">Location</span> response header), it can be difficult to assure that the new scheme is used consistently.</li><li>The resources identified by the new scheme will still be available using “http” and/or “https” URLs. Those URLs can “leak” into use, which can present security and operability issues. For example, using a new scheme to assure that requests don’t get sent to a “normal” Web site is likely to fail.</li><li>Features that rely upon the URL’s origin <a href="#RFC6454"><cite title="The Web Origin Concept">[RFC6454]</cite></a>, such as the Web’s same-origin policy, will be impacted by a change of scheme.</li><li>HTTP-specific features such as cookies <a href="#RFC6265"><cite title="HTTP State Management Mechanism">[RFC6265]</cite></a>, authentication <a href="#RFC7235"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Authentication">[RFC7235]</cite></a>, caching <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, and CORS <a href="#FETCH"><cite title="Fetch - Living Standard">[FETCH]</cite></a> might or might not work correctly, depending on how they are defined and implemented. Generally, they are designed and implemented with an assumption that the URL will always be “http” or “https”.</li><li>Web features that require a secure context <a href="#SECCTXT"><cite title="Secure Contexts">[SECCTXT]</cite></a> will likely treat a new scheme as insecure.</li></ul></div><div id="rfc.section.4.4.2.p.5"><p>See <a href="#RFC7595"><cite title="Guidelines and Registration Procedures for URI Schemes">[RFC7595]</cite></a> for more information about minting new URL schemes.</p></div></section><section id="transport-ports"><h4 id="rfc.section.4.4.3"><a href="#rfc.section.4.4.3">4.4.3.</a> <a href="#transport-ports">Transport Ports</a></h4><div id="rfc.section.4.4.3.p.1"><p>Applications that use HTTP can use the applicable default port (80 for HTTP, 443 for HTTPS), or they can be deployed upon other ports. This decision can be made at deployment time, or might be encouraged by the application’s specification (e.g., by registering a port for that application).</p></div><div id="rfc.section.4.4.3.p.2"><p>In either case, non-default ports will need to be reflected in the authority of all URLs for that resource; the only mechanism for changing a default port is changing the scheme (see <a href="#scheme" title="URL Schemes">Section 4.4.2</a>).</p></div><div id="rfc.section.4.4.3.p.3"><p>Using a port other than the default has privacy implications (i.e., the protocol can now be distinguished from other traffic), as well as operability concerns (as some networks might block or otherwise interfere with it). Privacy implications SHOULD be documented in Security Considerations.</p></div><div id="rfc.section.4.4.3.p.4"><p>See <a href="#RFC7605"><cite title="Recommendations on Using Assigned Transport Port Numbers">[RFC7605]</cite></a> for further guidance.</p></div></section></section><section id="http-methods"><h3 id="rfc.section.4.5"><a href="#rfc.section.4.5">4.5.</a> <a href="#http-methods">HTTP Methods</a></h3><div id="rfc.section.4.5.p.1"><p>Applications that use HTTP MUST confine themselves to using registered HTTP methods such as GET, POST, PUT, DELETE, and PATCH.</p></div><div id="rfc.section.4.5.p.2"><p>New HTTP methods are rare; they are required to be registered with IETF Review (see <a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a>), and are also required to be <em>generic</em>. That means that they need to be potentially applicable to all resources, not just those of one application.</p></div><div id="rfc.section.4.5.p.3"><p>While historically some applications (e.g., <a href="#RFC4791"><cite title="Calendaring Extensions to WebDAV (CalDAV)">[RFC4791]</cite></a>) have defined non-generic methods, <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a> now forbids this.</p></div><div id="rfc.section.4.5.p.4"><p>When authors believe that a new method is required, they are encouraged to engage with the HTTP community early, and document their proposal as a separate HTTP extension, rather than as part of an application’s specification.</p></div></section><section id="http-status-codes"><h3 id="rfc.section.4.6"><a href="#rfc.section.4.6">4.6.</a> <a href="#http-status-codes">HTTP Status Codes</a></h3><div id="rfc.section.4.6.p.1"><p>Applications that use HTTP MUST only use registered HTTP status codes.</p></div><div id="rfc.section.4.6.p.2"><p>As with methods, new HTTP status codes are rare, and required (by <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>) to be registered with IETF review. Similarly, HTTP status codes are generic; they are required (by <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>) to be potentially applicable to all resources, not just to those of one application.</p></div><div id="rfc.section.4.6.p.3"><p>When authors believe that a new status code is required, they are encouraged to engage with the HTTP community early, and document their proposal as a separate HTTP extension, rather than as part of an application’s specification.</p></div><div id="rfc.section.4.6.p.4"><p>The primary function of status codes is to convey HTTP semantics for the benefit of generic HTTP software, not application-specific semantics. Therefore, applications MUST NOT specify additional semantics or refine existing semantics for status codes.</p></div><div id="rfc.section.4.6.p.5"><p>In particular, specifying that a particular status code has a specific meaning in the context of an application is harmful, as these are not generic semantics, since the consumer needs to be in the context of the application to understand them.</p></div><div id="rfc.section.4.6.p.6"><p>Furthermore, applications using HTTP MUST NOT re-specify the semantics of HTTP status codes, even if it is only by copying their definition. They MUST NOT require specific reason phrases to be used; the reason phrase has no function in HTTP, and is not guaranteed to be preserved by implementations. The reason phrase is not carried in the <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> message format.</p></div><div id="rfc.section.4.6.p.7"><p>Typically, applications using HTTP will convey application-specific information in the message body and/or HTTP header fields, not the status code.</p></div><div id="rfc.section.4.6.p.8"><p>Specifications sometimes also create a “laundry list” of potential status codes, in an effort to be helpful. The problem with doing so is that such a list is never complete; for example, if a network proxy is interposed, the client might encounter a <span class="tt">407 Proxy Authentication Required</span> response; or, if the server is rate limiting the client, it might receive a <span class="tt">429 Too Many Requests</span> response.</p></div><div id="rfc.section.4.6.p.9"><p>Since the list of HTTP status codes can be added to, it’s safer to refer to it directly, and point out that clients SHOULD be able to handle all applicable protocol elements gracefully (i.e., falling back to the generic <span class="tt">n00</span> semantics of a given status code; e.g., <span class="tt">499</span> can be safely handled as <span class="tt">400</span> by clients that don’t recognise it).</p></div></section><section id="headers"><h3 id="rfc.section.4.7"><a href="#rfc.section.4.7">4.7.</a> <a href="#headers">HTTP Header Fields</a></h3><div id="rfc.section.4.7.p.1"><p>Applications that use HTTP MAY define new HTTP header fields, following the advice in <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 8.3.1.</p></div><div id="rfc.section.4.7.p.2" class="avoidbreakafter"><p>Typically, using HTTP header fields is appropriate in a few different situations:</p></div><div id="rfc.section.4.7.p.3"><ul><li>Their content is useful to intermediaries (who often wish to avoid parsing the body), and/or</li><li>Their content is useful to generic HTTP software (e.g., clients, servers), and/or</li><li>It is not possible to include their content in the message body (usually because a format does not allow it).</li></ul></div><div id="rfc.section.4.7.p.4"><p>If none of these motivations apply, using a header field is NOT RECOMMENDED.</p></div><div id="rfc.section.4.7.p.5"><p>New header fields MUST be registered, as per <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a> and <a href="#RFC3864"><cite title="Registration Procedures for Message Header Fields">[RFC3864]</cite></a>.</p></div><div id="rfc.section.4.7.p.6"><p>It is RECOMMENDED that header field names be short (even when HTTP/2 header compression is in effect, there is an overhead) but appropriately specific. In particular, if a header field is specific to an application, an identifier for that application SHOULD form a prefix to the header field name, separated by a “-“.</p></div><div id="rfc.section.4.7.p.7"><p>For example, if the “example” application needs to create three headers, they might be called “example-foo”, “example-bar” and “example-baz”. Note that the primary motivation here is to avoid consuming more generic header names, not to reserve a portion of the namespace for the application; see <a href="#RFC6648"><cite title='Deprecating the "X-" Prefix and Similar Constructs in Application Protocols'>[RFC6648]</cite></a> for related considerations.</p></div><div id="rfc.section.4.7.p.8"><p>The semantics of existing HTTP header fields MUST NOT be re-defined without updating their registration or defining an extension to them (if allowed). For example, an application using HTTP cannot specify that the <span class="tt">Location</span> header has a special meaning in a certain context.</p></div><div id="rfc.section.4.7.p.9"><p>If an application defines a request header field that might be used by a server to change the response’s headers or body, authors should point out that this has implications for caching; in general, such resources need to either make their responses uncacheable (e.g., with the “no-store” cache-control directive defined in <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 5.2.2.3) or consistently send the Vary response header (<a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, Section 7.1.4).</p></div><div id="rfc.section.4.7.p.10"><p>See <a href="#state" title="Authentication and Application State">Section 4.9</a> for requirements regarding header fields that carry application state (e.g,. Cookie).</p></div><div id="rfc.section.4.7.p.11"><p>Applications that use already-defined HTTP header fields MUST NOT modify their semantics or syntax, unless the definition of that header field explicitly allows it (e.g., with an extension field).</p></div></section><section id="payload"><h3 id="rfc.section.4.8"><a href="#rfc.section.4.8">4.8.</a> <a href="#payload">Defining Message Payloads</a></h3><div id="rfc.section.4.8.p.1"><p>There are many potential formats for payloads; for example, JSON <a href="#RFC8259"><cite title="The JavaScript Object Notation (JSON) Data Interchange Format">[RFC8259]</cite></a>, XML <a href="#XML"><cite title="Extensible Markup Language (XML) 1.0 (Fifth Edition)">[XML]</cite></a>, and CBOR <a href="#RFC7049"><cite title="Concise Binary Object Representation (CBOR)">[RFC7049]</cite></a>. Best practices for their use are out of scope for this document.</p></div><div id="rfc.section.4.8.p.2"><p>Applications SHOULD register distinct media types for each format they define; this makes it possible to identify them unambiguously and negotiate for their use. See <a href="#RFC6838"><cite title="Media Type Specifications and Registration Procedures">[RFC6838]</cite></a> for more information.</p></div></section><section id="state"><h3 id="rfc.section.4.9"><a href="#rfc.section.4.9">4.9.</a> <a href="#state">Authentication and Application State</a></h3><div id="rfc.section.4.9.p.1"><p>Applications that use HTTP MAY use stateful cookies <a href="#RFC6265"><cite title="HTTP State Management Mechanism">[RFC6265]</cite></a> to identify a client and/or store client-specific data to contextualise requests.</p></div><div id="rfc.section.4.9.p.2"><p>Applications that use HTTP MAY use HTTP authentication <a href="#RFC7235"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Authentication">[RFC7235]</cite></a> to identify clients. The Basic authentication scheme <a href="#RFC7617"><cite title="The 'Basic' HTTP Authentication Scheme">[RFC7617]</cite></a> MUST NOT be used unless the underlying transport is authenticated, integrity-protected and confidential (e.g., as provided the “HTTPS” URL scheme, or another using TLS). The Digest scheme <a href="#RFC7616"><cite title="HTTP Digest Access Authentication">[RFC7616]</cite></a> MUST NOT be used unless the underlying transport is similarly secure, or the chosen hash algorithm is not “MD5”.</p></div><div id="rfc.section.4.9.p.3"><p>In either case, it is important to carefully specify the scoping and use of these mechanisms; if they expose sensitive data or capabilities (e.g., by acting as an ambient authority), exploits are possible. Mitigations include using a request-specific token to assure the intent of the client.</p></div><div id="rfc.section.4.9.p.4"><p>Applications MUST NOT make assumptions about the relationship between separate requests on a single transport connection; doing so breaks many of the assumptions of HTTP as a stateless protocol, and will cause problems in interoperability, security, operability and evolution.</p></div></section><section id="browser"><h3 id="rfc.section.4.10"><a href="#rfc.section.4.10">4.10.</a> <a href="#browser">Co-Existing with Web Browsing</a></h3><div id="rfc.section.4.10.p.1"><p>Even if there is not an intent for an application that uses HTTP to be used with a Web browser, its resources will remain available to browsers and other HTTP clients.</p></div><div id="rfc.section.4.10.p.2"><p>This means that all such applications need to consider how browsers will interact with them, particularly regarding security.</p></div><div id="rfc.section.4.10.p.3"><p>For example, if an application’s state can be changed using a POST request, a Web browser can easily be coaxed into making that request by a HTML form on an arbitrary Web site.</p></div><div id="rfc.section.4.10.p.4"><p>Or, if a resource reflects data from the request into a response, that can be used to perform a Cross-Site Scripting attack on Web browsers directed to it.</p></div><div id="rfc.section.4.10.p.5"><p>This is only a small sample of the kinds of issues that applications using HTTP must consider. Generally, the best approach is to consider the application <em>as</em> a Web application, and to follow best practices for their secure development.</p></div><div id="rfc.section.4.10.p.6"><p>A complete enumeration of such practices is out of scope for this document. External resources are numerous; e.g., <a href="https://www.owasp.org/index.php/OWASP_Guide_Project">https://www.owasp.org/index.php/OWASP_Guide_Project</a>.</p></div></section><section id="other-apps"><h3 id="rfc.section.4.11"><a href="#rfc.section.4.11">4.11.</a> <a href="#other-apps">Co-Existing with Other Applications</a></h3><div id="rfc.section.4.11.p.1"><p>Because the origin <a href="#RFC6454"><cite title="The Web Origin Concept">[RFC6454]</cite></a> is how many HTTP capabilities are scoped, applications also need to consider how deployments might interact with other applications (including Web browsing) on the same origin.</p></div><div id="rfc.section.4.11.p.2"><p>For example, if Cookies <a href="#RFC6265"><cite title="HTTP State Management Mechanism">[RFC6265]</cite></a> are used to carry application state, they will be sent with all requests to the origin by default, unless scoped by path, and the application might receive cookies from other applications on the origin. This can lead to security issues, as well as collisions in cookie name.</p></div><div id="rfc.section.4.11.p.3"><p>As a result, when specifying the use of Cookies, HTTP authentication <a href="#RFC7235"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Authentication">[RFC7235]</cite></a>, or other origin-wide HTTP mechanisms, applications using HTTP SHOULD NOT mandate the use of a particular identifier, but instead let deployments configure them.</p></div><div id="rfc.section.4.11.p.4"><p>Note that dedicating a hostname to a single application is not a solution to the issues above; see <a href="#RFC7320"><cite title="URI Design and Ownership">[RFC7320]</cite></a>.</p></div><div id="rfc.section.4.11.p.5"><p>Modern Web browsers constrain the ability of content from one origin to access resources from another, to avoid the “confused deputy” problem. As a result, applications that wish to expose cross-origin data to browsers will need to implement <a href="#W3C.REC-cors-20140116"><cite title="Cross-Origin Resource Sharing">[W3C.REC-cors-20140116]</cite></a>.</p></div></section></section><section id="iana-considerations"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.5.p.1"><p>This document has no requirements for IANA.</p></div></section><section id="security-considerations"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.6.p.1"><p><a href="#state" title="Authentication and Application State">Section 4.9</a> discusses the impact of using stateful mechanisms in the protocol as ambient authority, and suggests a mitigation.</p></div><div id="rfc.section.6.p.2"><p><a href="#scheme" title="URL Schemes">Section 4.4.2</a> requires support for ‘https’ URLs, and discourages the use of ‘http’ URLs, to provide authentication, integrity and confidentiality, as well as mitigate pervasive monitoring attacks.</p></div><div id="rfc.section.6.p.3"><p><a href="#browser" title="Co-Existing with Web Browsing">Section 4.10</a> highlights the implications of Web browsers’ capabilities on applications that use HTTP.</p></div><div id="rfc.section.6.p.4"><p><a href="#other-apps" title="Co-Existing with Other Applications">Section 4.11</a> discusses the issues that arise when applications are deployed on the same origin as Web sites (and other applications).</p></div><div id="rfc.section.6.p.5"><p>Applications that use HTTP in a manner that involves modification of implementations – for example, requiring support for a new URL scheme, or a non-standard method – risk having those implementations “fork” from their parent HTTP implementations, with the possible result that they do not benefit from patches and other security improvements incorporated upstream.</p></div></section><section id="rfc.references"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a> References</h2><section><div id="rfc.references.1"><h3 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> Normative References</h3><dl class="reference"><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP 14, RFC 2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI 10.17487/RFC2119</a>, March 1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC2818">[RFC2818]</dt><dd>Rescorla, E., “<a href="https://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>”, RFC 2818, <a href="http://dx.doi.org/10.17487/RFC2818">DOI 10.17487/RFC2818</a>, May 2000, &lt;<a href="https://www.rfc-editor.org/info/rfc2818">https://www.rfc-editor.org/info/rfc2818</a>&gt;.</dd><dt id="RFC3864">[RFC3864]</dt><dd>Klyne, G., Nottingham, M., and J. Mogul, “<a href="https://tools.ietf.org/html/rfc3864">Registration Procedures for Message Header Fields</a>”, BCP 90, RFC 3864, <a href="http://dx.doi.org/10.17487/RFC3864">DOI 10.17487/RFC3864</a>, September 2004, &lt;<a href="https://www.rfc-editor.org/info/rfc3864">https://www.rfc-editor.org/info/rfc3864</a>&gt;.</dd><dt id="RFC6454">[RFC6454]</dt><dd>Barth, A., “<a href="https://tools.ietf.org/html/rfc6454">The Web Origin Concept</a>”, RFC 6454, <a href="http://dx.doi.org/10.17487/RFC6454">DOI 10.17487/RFC6454</a>, December 2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6454">https://www.rfc-editor.org/info/rfc6454</a>&gt;.</dd><dt id="RFC6648">[RFC6648]</dt><dd>Saint-Andre, P., Crocker, D., and M. Nottingham, “<a href="https://tools.ietf.org/html/rfc6648">Deprecating the "X-" Prefix and Similar Constructs in Application Protocols</a>”, BCP 178, RFC 6648, <a href="http://dx.doi.org/10.17487/RFC6648">DOI 10.17487/RFC6648</a>, June 2012, &lt;<a href="https://www.rfc-editor.org/info/rfc6648">https://www.rfc-editor.org/info/rfc6648</a>&gt;.</dd><dt id="RFC6838">[RFC6838]</dt><dd>Freed, N., Klensin, J., and T. Hansen, “<a href="https://tools.ietf.org/html/rfc6838">Media Type Specifications and Registration Procedures</a>”, BCP 13, RFC 6838, <a href="http://dx.doi.org/10.17487/RFC6838">DOI 10.17487/RFC6838</a>, January 2013, &lt;<a href="https://www.rfc-editor.org/info/rfc6838">https://www.rfc-editor.org/info/rfc6838</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC 7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI 10.17487/RFC7230</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC7231">[RFC7231]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, RFC 7231, <a href="http://dx.doi.org/10.17487/RFC7231">DOI 10.17487/RFC7231</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7231">https://www.rfc-editor.org/info/rfc7231</a>&gt;.</dd><dt id="RFC7232">[RFC7232]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7232">Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</a>”, RFC 7232, <a href="http://dx.doi.org/10.17487/RFC7232">DOI 10.17487/RFC7232</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7232">https://www.rfc-editor.org/info/rfc7232</a>&gt;.</dd><dt id="RFC7233">[RFC7233]</dt><dd>Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7233">Hypertext Transfer Protocol (HTTP/1.1): Range Requests</a>”, RFC 7233, <a href="http://dx.doi.org/10.17487/RFC7233">DOI 10.17487/RFC7233</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7233">https://www.rfc-editor.org/info/rfc7233</a>&gt;.</dd><dt id="RFC7234">[RFC7234]</dt><dd>Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7234">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>”, RFC 7234, <a href="http://dx.doi.org/10.17487/RFC7234">DOI 10.17487/RFC7234</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7234">https://www.rfc-editor.org/info/rfc7234</a>&gt;.</dd><dt id="RFC7235">[RFC7235]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7235">Hypertext Transfer Protocol (HTTP/1.1): Authentication</a>”, RFC 7235, <a href="http://dx.doi.org/10.17487/RFC7235">DOI 10.17487/RFC7235</a>, June 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7235">https://www.rfc-editor.org/info/rfc7235</a>&gt;.</dd><dt id="RFC7301">[RFC7301]</dt><dd>Friedl, S., Popov, A., Langley, A., and E. Stephan, “<a href="https://tools.ietf.org/html/rfc7301">Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</a>”, RFC 7301, <a href="http://dx.doi.org/10.17487/RFC7301">DOI 10.17487/RFC7301</a>, July 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7301">https://www.rfc-editor.org/info/rfc7301</a>&gt;.</dd><dt id="RFC7320">[RFC7320]</dt><dd>Nottingham, M., “<a href="https://tools.ietf.org/html/rfc7320">URI Design and Ownership</a>”, BCP 190, RFC 7320, <a href="http://dx.doi.org/10.17487/RFC7320">DOI 10.17487/RFC7320</a>, July 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7320">https://www.rfc-editor.org/info/rfc7320</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC 7540, <a href="http://dx.doi.org/10.17487/RFC7540">DOI 10.17487/RFC7540</a>, May 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7540">https://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd><dt id="RFC8174">[RFC8174]</dt><dd>Leiba, B., “<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>”, BCP 14, RFC 8174, <a href="http://dx.doi.org/10.17487/RFC8174">DOI 10.17487/RFC8174</a>, May 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.</dd><dt id="RFC8288">[RFC8288]</dt><dd>Nottingham, M., “<a href="https://tools.ietf.org/html/rfc8288">Web Linking</a>”, RFC 8288, <a href="http://dx.doi.org/10.17487/RFC8288">DOI 10.17487/RFC8288</a>, October 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8288">https://www.rfc-editor.org/info/rfc8288</a>&gt;.</dd><dt id="W3C.REC-cors-20140116">[W3C.REC-cors-20140116]</dt><dd>Kesteren, A., “<a href="http://www.w3.org/TR/2014/REC-cors-20140116">Cross-Origin Resource Sharing</a>”, World Wide Web Consortium Recommendation REC-cors-20140116, January 2014, &lt;<a href="http://www.w3.org/TR/2014/REC-cors-20140116">http://www.w3.org/TR/2014/REC-cors-20140116</a>&gt;.</dd></dl></div></section><section><div id="rfc.references.2"><h3 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> Informative References</h3><dl class="reference"><dt id="FETCH">[FETCH]</dt><dd>WHATWG, “<a href="https://fetch.spec.whatwg.org">Fetch - Living Standard</a>”, n.d., &lt;<a href="https://fetch.spec.whatwg.org">https://fetch.spec.whatwg.org</a>&gt;.</dd><dt id="HTML5">[HTML5]</dt><dd>WHATWG, “<a href="https://html.spec.whatwg.org">HTML - Living Standard</a>”, n.d., &lt;<a href="https://html.spec.whatwg.org">https://html.spec.whatwg.org</a>&gt;.</dd><dt id="RFC0793">[RFC0793]</dt><dd>Postel, J., “<a href="https://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>”, STD 7, RFC 793, <a href="http://dx.doi.org/10.17487/RFC0793">DOI 10.17487/RFC0793</a>, September 1981, &lt;<a href="https://www.rfc-editor.org/info/rfc793">https://www.rfc-editor.org/info/rfc793</a>&gt;.</dd><dt id="RFC0854">[RFC0854]</dt><dd>Postel, J. and J. Reynolds, “<a href="https://tools.ietf.org/html/rfc854">Telnet Protocol Specification</a>”, STD 8, RFC 854, <a href="http://dx.doi.org/10.17487/RFC0854">DOI 10.17487/RFC0854</a>, May 1983, &lt;<a href="https://www.rfc-editor.org/info/rfc854">https://www.rfc-editor.org/info/rfc854</a>&gt;.</dd><dt id="RFC0959">[RFC0959]</dt><dd>Postel, J. and J. Reynolds, “<a href="https://tools.ietf.org/html/rfc959">File Transfer Protocol</a>”, STD 9, RFC 959, <a href="http://dx.doi.org/10.17487/RFC0959">DOI 10.17487/RFC0959</a>, October 1985, &lt;<a href="https://www.rfc-editor.org/info/rfc959">https://www.rfc-editor.org/info/rfc959</a>&gt;.</dd><dt id="RFC2821">[RFC2821]</dt><dd>Klensin, J., Ed., “<a href="https://tools.ietf.org/html/rfc2821">Simple Mail Transfer Protocol</a>”, RFC 2821, <a href="http://dx.doi.org/10.17487/RFC2821">DOI 10.17487/RFC2821</a>, April 2001, &lt;<a href="https://www.rfc-editor.org/info/rfc2821">https://www.rfc-editor.org/info/rfc2821</a>&gt;.</dd><dt id="RFC3205">[RFC3205]</dt><dd>Moore, K., “<a href="https://tools.ietf.org/html/rfc3205">On the use of HTTP as a Substrate</a>”, BCP 56, RFC 3205, <a href="http://dx.doi.org/10.17487/RFC3205">DOI 10.17487/RFC3205</a>, February 2002, &lt;<a href="https://www.rfc-editor.org/info/rfc3205">https://www.rfc-editor.org/info/rfc3205</a>&gt;.</dd><dt id="RFC4367">[RFC4367]</dt><dd>Rosenberg, J., Ed. and IAB, “<a href="https://tools.ietf.org/html/rfc4367">What's in a Name: False Assumptions about DNS Names</a>”, RFC 4367, <a href="http://dx.doi.org/10.17487/RFC4367">DOI 10.17487/RFC4367</a>, February 2006, &lt;<a href="https://www.rfc-editor.org/info/rfc4367">https://www.rfc-editor.org/info/rfc4367</a>&gt;.</dd><dt id="RFC4791">[RFC4791]</dt><dd>Daboo, C., Desruisseaux, B., and L. Dusseault, “<a href="https://tools.ietf.org/html/rfc4791">Calendaring Extensions to WebDAV (CalDAV)</a>”, RFC 4791, <a href="http://dx.doi.org/10.17487/RFC4791">DOI 10.17487/RFC4791</a>, March 2007, &lt;<a href="https://www.rfc-editor.org/info/rfc4791">https://www.rfc-editor.org/info/rfc4791</a>&gt;.</dd><dt id="RFC5785">[RFC5785]</dt><dd>Nottingham, M. and E. Hammer-Lahav, “<a href="https://tools.ietf.org/html/rfc5785">Defining Well-Known Uniform Resource Identifiers (URIs)</a>”, RFC 5785, <a href="http://dx.doi.org/10.17487/RFC5785">DOI 10.17487/RFC5785</a>, April 2010, &lt;<a href="https://www.rfc-editor.org/info/rfc5785">https://www.rfc-editor.org/info/rfc5785</a>&gt;.</dd><dt id="RFC6265">[RFC6265]</dt><dd>Barth, A., “<a href="https://tools.ietf.org/html/rfc6265">HTTP State Management Mechanism</a>”, RFC 6265, <a href="http://dx.doi.org/10.17487/RFC6265">DOI 10.17487/RFC6265</a>, April 2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6265">https://www.rfc-editor.org/info/rfc6265</a>&gt;.</dd><dt id="RFC6455">[RFC6455]</dt><dd>Fette, I. and A. Melnikov, “<a href="https://tools.ietf.org/html/rfc6455">The WebSocket Protocol</a>”, RFC 6455, <a href="http://dx.doi.org/10.17487/RFC6455">DOI 10.17487/RFC6455</a>, December 2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6455">https://www.rfc-editor.org/info/rfc6455</a>&gt;.</dd><dt id="RFC7049">[RFC7049]</dt><dd>Bormann, C. and P. Hoffman, “<a href="https://tools.ietf.org/html/rfc7049">Concise Binary Object Representation (CBOR)</a>”, RFC 7049, <a href="http://dx.doi.org/10.17487/RFC7049">DOI 10.17487/RFC7049</a>, October 2013, &lt;<a href="https://www.rfc-editor.org/info/rfc7049">https://www.rfc-editor.org/info/rfc7049</a>&gt;.</dd><dt id="RFC7258">[RFC7258]</dt><dd>Farrell, S. and H. Tschofenig, “<a href="https://tools.ietf.org/html/rfc7258">Pervasive Monitoring Is an Attack</a>”, BCP 188, RFC 7258, <a href="http://dx.doi.org/10.17487/RFC7258">DOI 10.17487/RFC7258</a>, May 2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7258">https://www.rfc-editor.org/info/rfc7258</a>&gt;.</dd><dt id="RFC7595">[RFC7595]</dt><dd>Thaler, D., Ed., Hansen, T., and T. Hardie, “<a href="https://tools.ietf.org/html/rfc7595">Guidelines and Registration Procedures for URI Schemes</a>”, BCP 35, RFC 7595, <a href="http://dx.doi.org/10.17487/RFC7595">DOI 10.17487/RFC7595</a>, June 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7595">https://www.rfc-editor.org/info/rfc7595</a>&gt;.</dd><dt id="RFC7605">[RFC7605]</dt><dd>Touch, J., “<a href="https://tools.ietf.org/html/rfc7605">Recommendations on Using Assigned Transport Port Numbers</a>”, BCP 165, RFC 7605, <a href="http://dx.doi.org/10.17487/RFC7605">DOI 10.17487/RFC7605</a>, August 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7605">https://www.rfc-editor.org/info/rfc7605</a>&gt;.</dd><dt id="RFC7616">[RFC7616]</dt><dd>Shekh-Yusef, R., Ed., Ahrens, D., and S. Bremer, “<a href="https://tools.ietf.org/html/rfc7616">HTTP Digest Access Authentication</a>”, RFC 7616, <a href="http://dx.doi.org/10.17487/RFC7616">DOI 10.17487/RFC7616</a>, September 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7616">https://www.rfc-editor.org/info/rfc7616</a>&gt;.</dd><dt id="RFC7617">[RFC7617]</dt><dd>Reschke, J., “<a href="https://tools.ietf.org/html/rfc7617">The 'Basic' HTTP Authentication Scheme</a>”, RFC 7617, <a href="http://dx.doi.org/10.17487/RFC7617">DOI 10.17487/RFC7617</a>, September 2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7617">https://www.rfc-editor.org/info/rfc7617</a>&gt;.</dd><dt id="RFC8259">[RFC8259]</dt><dd>Bray, T., Ed., “<a href="https://tools.ietf.org/html/rfc8259">The JavaScript Object Notation (JSON) Data Interchange Format</a>”, STD 90, RFC 8259, <a href="http://dx.doi.org/10.17487/RFC8259">DOI 10.17487/RFC8259</a>, December 2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8259">https://www.rfc-editor.org/info/rfc8259</a>&gt;.</dd><dt id="SECCTXT">[SECCTXT]</dt><dd>West, M., “<a href="https://www.w3.org/TR/2016/CR-secure-contexts-20160915">Secure Contexts</a>”, World Wide Web Consortium CR CR-secure-contexts-20160915, September 2016, &lt;<a href="https://www.w3.org/TR/2016/CR-secure-contexts-20160915">https://www.w3.org/TR/2016/CR-secure-contexts-20160915</a>&gt;.</dd><dt id="XML">[XML]</dt><dd>Bray, T., Paoli, J., Sperberg-McQueen, M., Maler, E., and F. Yergeau, “<a href="http://www.w3.org/TR/2008/REC-xml-20081126">Extensible Markup Language (XML) 1.0 (Fifth Edition)</a>”, World Wide Web Consortium Recommendation REC-xml-20081126, November 2008, &lt;<a href="http://www.w3.org/TR/2008/REC-xml-20081126">http://www.w3.org/TR/2008/REC-xml-20081126</a>&gt;.</dd></dl></div></section></section><section id="changes-from-rfc-3205"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a> <a href="#changes-from-rfc-3205">Changes from RFC 3205</a></h2><div id="rfc.section.A.p.1"><p><a href="#RFC3205"><cite title="On the use of HTTP as a Substrate">[RFC3205]</cite></a> captured the Best Current Practice in the early 2000’s, based on the concerns facing protocol designers at the time. Use of HTTP has changed considerably since then, and as a result this document is substantially different. As a result, the changes are too numerous to list individually.</p></div></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Author's Address</a></h2><address><b>Mark Nottingham</b><br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="https://www.mnot.net/">https://www.mnot.net/</a></address></section></body></html>
