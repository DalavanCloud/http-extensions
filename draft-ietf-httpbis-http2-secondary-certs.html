<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Secondary Certificate Authentication in HTTP/2</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      #rfc\.toc > ul ul {
        list-style: none;
      }
      #sidebar {
        position: fixed;
        height: 90%;
        overflow-y: auto;
        font-size: 90%;
      }
      .container .nav-sublist {
        padding-left: 20px;
        padding-right: 10px;
        font-size: 90%;
      }
      .container .navbar-brand {
        padding-top: 0;
      }
      .container .nav > li > a {
        padding: 10px 7px 5px 15px;
        display: inline-block;
      }
      .container .nav > li > a + a {
        padding: 10px 15px 5px 7px;
        display: inline-block;
      }
      .container .nav > li > a {
        padding: 5px 10px;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
      span.tt {
        font: 11pt consolas, monospace;
        font-size-adjust: none;
      }
    </style><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Discovering Additional Certificates at the HTTP/2 Layer" href="#rfc.section.2"><link rel="Chapter" title="3 Certificates Frames for HTTP/2" href="#rfc.section.3"><link rel="Chapter" title="4 Indicating failures during HTTP-Layer Certificate Authentication" href="#rfc.section.4"><link rel="Chapter" title="5 Security Considerations" href="#rfc.section.5"><link rel="Chapter" title="6 IANA Considerations" href="#rfc.section.6"><link rel="Chapter" title="7 Acknowledgements" href="#rfc.section.7"><link rel="Chapter" href="#rfc.section.8" title="8 References"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: SAXON 9.1.0.8 from Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Bishop, M."><meta name="dcterms.creator" content="Sullivan, N."><meta name="dcterms.creator" content="Thomson, M."><meta name="dcterms.identifier" content="urn:ietf:id:draft-ietf-httpbis-http2-secondary-certs-latest"><meta name="dcterms.issued" content="2017-12-11"><meta name="dcterms.abstract" content="TLS provides fundamental mutual authentication services for HTTP, supporting up to one server certificate and up to one client certificate associated to the session to prove client and server identities as necessary. This draft provides mechanisms for providing additional such certificates at the HTTP layer when these constraints are not sufficient.Many HTTP servers host content from several origins. HTTP/2 permits clients to reuse an existing HTTP connection to a server provided that the secondary origin is also in the certificate provided during the TLS handshake.In many cases, servers will wish to maintain separate certificates for different origins but still desire the benefits of a shared HTTP connection. Similarly, servers may require clients to present authentication, but have different requirements based on the content the client is attempting to access.This document describes how TLS exported authenticators can be used to provide proof of ownership of additional certificates to the HTTP layer to support both scenarios."><meta name="description" content="TLS provides fundamental mutual authentication services for HTTP, supporting up to one server certificate and up to one client certificate associated to the session to prove client and server identities as necessary. This draft provides mechanisms for providing additional such certificates at the HTTP layer when these constraints are not sufficient.Many HTTP servers host content from several origins. HTTP/2 permits clients to reuse an existing HTTP connection to a server provided that the secondary origin is also in the certificate provided during the TLS handshake.In many cases, servers will wish to maintain separate certificates for different origins but still desire the benefits of a shared HTTP connection. Similarly, servers may require clients to present authentication, but have different requirements based on the content the client is attempting to access.This document describes how TLS exported authenticators can be used to provide proof of ownership of additional certificates to the HTTP layer to support both scenarios."></head><body><div class="container" id="top"><div class="row"><div class="col-md-4 col-md-push-8 hidden-sm hidden-xs" id="sidebar" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top">draft-ietf-httpbis-http2-secondary-certs-latest</a></div><br clear="all"><div class=""><div id="rfc.toc"><ul class="nav"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#server-certificate-authentication">Server Certificate Authentication</a></li><li><a href="#rfc.section.1.2">1.2.</a>&nbsp;&nbsp;&nbsp;<a href="#client-certificate-authentication">Client Certificate Authentication</a><ul><li><a href="#rfc.section.1.2.1">1.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#http11-using-tls-12-and-previous">HTTP/1.1 using TLS 1.2 and previous</a></li><li><a href="#rfc.section.1.2.2">1.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#http11-using-tls-13">HTTP/1.1 using TLS 1.3</a></li><li><a href="#rfc.section.1.2.3">1.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#http2">HTTP/2</a></li></ul></li><li><a href="#rfc.section.1.3">1.3.</a>&nbsp;&nbsp;&nbsp;<a href="#http-layer-certificate-authentication">HTTP-Layer Certificate Authentication</a></li><li><a href="#rfc.section.1.4">1.4.</a>&nbsp;&nbsp;&nbsp;<a href="#terminology">Terminology</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#discovery">Discovering Additional Certificates at the HTTP/2 Layer</a><ul><li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#setting">Indicating support for HTTP-layer certificate authentication</a></li><li><a href="#rfc.section.2.2">2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#cert-available">Making certificates or requests available</a></li><li><a href="#rfc.section.2.3">2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#cert-challenge">Requiring certificate authentication</a></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#certs-http2">Certificates Frames for HTTP/2</a><ul><li><a href="#rfc.section.3.1">3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#http-cert-needed">The CERTIFICATE_NEEDED frame</a></li><li><a href="#rfc.section.3.2">3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#http-use-certificate">The USE_CERTIFICATE Frame</a></li><li><a href="#rfc.section.3.3">3.3.</a>&nbsp;&nbsp;&nbsp;<a href="#http-cert-request">The CERTIFICATE_REQUEST Frame</a></li><li><a href="#rfc.section.3.4">3.4.</a>&nbsp;&nbsp;&nbsp;<a href="#http-cert">The CERTIFICATE Frame</a><ul><li><a href="#rfc.section.3.4.1">3.4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#exp-auth">Exported Authenticator Characteristics</a></li></ul></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#errors">Indicating failures during HTTP-Layer Certificate Authentication</a></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#security">Security Considerations</a><ul><li><a href="#rfc.section.5.1">5.1.</a>&nbsp;&nbsp;&nbsp;<a href="#impersonation">Impersonation</a></li><li><a href="#rfc.section.5.2">5.2.</a>&nbsp;&nbsp;&nbsp;<a href="#fingerprinting">Fingerprinting</a></li><li><a href="#rfc.section.5.3">5.3.</a>&nbsp;&nbsp;&nbsp;<a href="#denial-of-service">Denial of Service</a></li><li><a href="#rfc.section.5.4">5.4.</a>&nbsp;&nbsp;&nbsp;<a href="#confusion-about-state">Confusion About State</a></li></ul></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#iana">IANA Considerations</a><ul><li><a href="#rfc.section.6.1">6.1.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-setting">HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting</a></li><li><a href="#rfc.section.6.2">6.2.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-frame">New HTTP/2 Frames</a></li><li><a href="#rfc.section.6.3">6.3.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-errors">New HTTP/2 Error Codes</a></li></ul></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#ack">Acknowledgements</a></li><li><a href="#rfc.section.8">8.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li><a href="#rfc.section.8.1">8.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.8.2">8.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></div></div></div></div><div class="col-md-8 main" role="main"><header><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">HTTP Working Group</td><td class="text-right">M. Bishop</td></tr><tr><td class="text-left">Internet-Draft</td><td class="text-right">Akamai</td></tr><tr><td class="text-left">Intended status: Standards Track</td><td class="text-right">N. Sullivan</td></tr><tr><td class="text-left">Expires: June 14, 2018</td><td class="text-right">Cloudflare</td></tr><tr><td class="text-left"></td><td class="text-right">M. Thomson</td></tr><tr><td class="text-left"></td><td class="text-right">Mozilla</td></tr><tr><td class="text-left"></td><td class="text-right">December 11, 2017</td></tr></tbody></table><div id="rfc.title"><h1>Secondary Certificate Authentication in HTTP/2</h1><div class="filename">draft-ietf-httpbis-http2-secondary-certs-latest</div></div></header><hr><h2 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h2><div class="lead"><div id="rfc.abstract.p.1"><p>TLS provides fundamental mutual authentication services for HTTP, supporting up to one server certificate and up to one client certificate associated to the session to prove client and server identities as necessary. This draft provides mechanisms for providing additional such certificates at the HTTP layer when these constraints are not sufficient.</p></div><div id="rfc.abstract.p.2"><p>Many HTTP servers host content from several origins. HTTP/2 permits clients to reuse an existing HTTP connection to a server provided that the secondary origin is also in the certificate provided during the TLS handshake.</p></div><div id="rfc.abstract.p.3"><p>In many cases, servers will wish to maintain separate certificates for different origins but still desire the benefits of a shared HTTP connection. Similarly, servers may require clients to present authentication, but have different requirements based on the content the client is attempting to access.</p></div><div id="rfc.abstract.p.4"><p>This document describes how TLS exported authenticators can be used to provide proof of ownership of additional certificates to the HTTP layer to support both scenarios.</p></div></div><section id="rfc.note.1" class="note"><h2><a href="#rfc.note.1">Note to Readers</a></h2><div id="rfc.note.1.p.1"><p>Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at <a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">https://lists.w3.org/Archives/Public/ietf-http-wg/</a>.</p></div><div id="rfc.note.1.p.2"><p>Working Group information can be found at <a href="http://httpwg.github.io/">http://httpwg.github.io/</a>; source code and issues list for this draft can be found at <a href="https://github.com/httpwg/http-extensions/labels/secondary-certs">https://github.com/httpwg/http-extensions/labels/secondary-certs</a>.</p></div></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on June 14, 2018.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright © 2017 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><hr class="hidden-print"><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>HTTP clients need to know that the content they receive on a connection comes from the origin that they intended to retrieve in from. The traditional form of server authentication in HTTP has been in the form of X.509 certificates provided during the TLS <a href="#I-D.ietf-tls-tls13">RFC5246</a> <cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[I-D.ietf-tls-tls13]</cite> handshake.</p></div><div id="rfc.section.1.p.2"><p>Many existing HTTP <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> servers also have authentication requirements for the resources they serve. Of the bountiful authentication options available for authenticating HTTP requests, client certificates present a unique challenge for resource-specific authentication requirements because of the interaction with the underlying TLS layer.</p></div><div id="rfc.section.1.p.3"><p>TLS 1.2 <a href="#RFC5246"><cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[RFC5246]</cite></a> supports one server and one client certificate on a connection. These certificates may contain multiple identities, but only one certificate may be provided.</p></div><section id="server-certificate-authentication"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a>&nbsp;<a href="#server-certificate-authentication">Server Certificate Authentication</a></h3><div id="rfc.section.1.1.p.1"><p>Section 9.1.1 of <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> describes how connections may be used to make requests from multiple origins as long as the server is authoritative for both. A server is considered authoritative for an origin if DNS resolves the origin to the IP address of the server and (for TLS) if the certificate presented by the server contains the origin in the Subject Alternative Names field.</p></div><div id="rfc.section.1.1.p.2"><p><a href="#RFC7838"><cite title="HTTP Alternative Services">[RFC7838]</cite></a> enables a step of abstraction from the DNS resolution. If both hosts have provided an Alternative Service at hostnames which resolve to the IP address of the server, they are considered authoritative just as if DNS resolved the origin itself to that address. However, the server’s one TLS certificate is still required to contain the name of each origin in question.</p></div><div id="rfc.section.1.1.p.3"><p><a href="#I-D.ietf-httpbis-origin-frame"><cite title="The ORIGIN HTTP/2 Frame">[I-D.ietf-httpbis-origin-frame]</cite></a> relaxes the requirement to perform the DNS lookup if already connected to a server with an appropriate certificate which claims support for a particular origin.</p></div><div id="rfc.section.1.1.p.4"><p>Servers which host many origins often would prefer to have separate certificates for some sets of origins. This may be for ease of certificate management (the ability to separately revoke or renew them), due to different sources of certificates (a CDN acting on behalf of multiple origins), or other factors which might drive this administrative decision. Clients connecting to such origins cannot currently reuse connections, even if both client and server would prefer to do so.</p></div><div id="rfc.section.1.1.p.5"><p>Because the TLS SNI extension is exchanged in the clear, clients might also prefer to retrieve certificates inside the encrypted context. When this information is sensitive, it might be advantageous to request a general-purpose certificate or anonymous ciphersuite at the TLS layer, while acquiring the “real” certificate in HTTP after the connection is established.</p></div></section><section id="client-certificate-authentication"><h3 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a>&nbsp;<a href="#client-certificate-authentication">Client Certificate Authentication</a></h3><div id="rfc.section.1.2.p.1"><p>For servers that wish to use client certificates to authenticate users, they might request client authentication during or immediately after the TLS handshake. However, if not all users or resources need certificate-based authentication, a request for a certificate has the unfortunate consequence of triggering the client to seek a certificate, possibly requiring user interaction, network traffic, or other time-consuming activities. During this time, the connection is stalled in many implementations. Such a request can result in a poor experience, particularly when sent to a client that does not expect the request.</p></div><div id="rfc.section.1.2.p.2"><p>The TLS 1.3 CertificateRequest can be used by servers to give clients hints about which certificate to offer. Servers that rely on certificate-based authentication might request different certificates for different resources. Such a server cannot use contextual information about the resource to construct an appropriate TLS CertificateRequest message during the initial handshake.</p></div><div id="rfc.section.1.2.p.3"><p>Consequently, client certificates are requested at connection establishment time only in cases where all clients are expected or required to have a single certificate that is used for all resources. Many other uses for client certificates are reactive, that is, certificates are requested in response to the client making a request.</p></div><section id="http11-using-tls-12-and-previous"><h4 id="rfc.section.1.2.1"><a href="#rfc.section.1.2.1">1.2.1.</a>&nbsp;<a href="#http11-using-tls-12-and-previous">HTTP/1.1 using TLS 1.2 and previous</a></h4><div id="rfc.section.1.2.1.p.1"><p>In HTTP/1.1, a server that relies on client authentication for a subset of users or resources does not request a certificate when the connection is established. Instead, it only requests a client certificate when a request is made to a resource that requires a certificate. TLS 1.2 <a href="#RFC5246"><cite title="The Transport Layer Security (TLS) Protocol Version 1.2">[RFC5246]</cite></a> accomodates this by permitting the server to request a new TLS handshake, in which the server will request the client’s certificate.</p></div><div id="rfc.section.1.2.1.p.2"><p><a href="#ex-http11">Figure&nbsp;1</a> shows the server initiating a TLS-layer renegotiation in response to receiving an HTTP/1.1 request to a protected resource.</p></div><div id="ex-http11"></div><div id="rfc.figure.1"><pre>
Client                                      Server
   -- (HTTP) GET /protected -------------------&gt; *1
   &lt;---------------------- (TLS) HelloRequest -- *2
   -- (TLS) ClientHello -----------------------&gt;
   &lt;------------------ (TLS) ServerHello, ... --
   &lt;---------------- (TLS) CertificateRequest -- *3
   -- (TLS) ..., Certificate ------------------&gt; *4
   -- (TLS) Finished --------------------------&gt;
   &lt;-------------------------- (TLS) Finished --
   &lt;--------------------------- (HTTP) 200 OK -- *5
</pre></div><p class="figure">Figure 1: HTTP/1.1 Reactive Certificate Authentication with TLS 1.2</p><div id="rfc.section.1.2.1.p.3"><p>In this example, the server receives a request for a protected resource (at *1 on <a href="#ex-http11">Figure&nbsp;1</a>). Upon performing an authorization check, the server determines that the request requires authentication using a client certificate and that no such certificate has been provided.</p></div><div id="rfc.section.1.2.1.p.4"><p>The server initiates TLS renegotiation by sending a TLS HelloRequest (at *2). The client then initiates a TLS handshake. Note that some TLS messages are elided from the figure for the sake of brevity.</p></div><div id="rfc.section.1.2.1.p.5"><p>The critical messages for this example are the server requesting a certificate with a TLS CertificateRequest (*3); this request might use information about the request or resource. The client then provides a certificate and proof of possession of the private key in Certificate and CertificateVerify messages (*4).</p></div><div id="rfc.section.1.2.1.p.6"><p>When the handshake completes, the server performs any authorization checks a second time. With the client certificate available, it then authorizes the request and provides a response (*5).</p></div></section><section id="http11-using-tls-13"><h4 id="rfc.section.1.2.2"><a href="#rfc.section.1.2.2">1.2.2.</a>&nbsp;<a href="#http11-using-tls-13">HTTP/1.1 using TLS 1.3</a></h4><div id="rfc.section.1.2.2.p.1"><p>TLS 1.3 <a href="#I-D.ietf-tls-tls13"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[I-D.ietf-tls-tls13]</cite></a> introduces a new client authentication mechanism that allows for clients to authenticate after the handshake has been completed. For the purposes of authenticating an HTTP request, this is functionally equivalent to renegotiation. <a href="#ex-tls13">Figure&nbsp;2</a> shows the simpler exchange this enables.</p></div><div id="ex-tls13"></div><div id="rfc.figure.2"><pre>
Client                                      Server
   -- (HTTP) GET /protected -------------------&gt;
   &lt;---------------- (TLS) CertificateRequest --
   -- (TLS) Certificate, CertificateVerify,
               Finished -----------------------&gt;
   &lt;--------------------------- (HTTP) 200 OK --
</pre></div><p class="figure">Figure 2: HTTP/1.1 Reactive Certificate Authentication with TLS 1.3</p><div id="rfc.section.1.2.2.p.2"><p>TLS 1.3 does not support renegotiation, instead supporting direct client authentication. In contrast to the TLS 1.2 example, in TLS 1.3, a server can simply request a certificate.</p></div></section><section id="http2"><h4 id="rfc.section.1.2.3"><a href="#rfc.section.1.2.3">1.2.3.</a>&nbsp;<a href="#http2">HTTP/2</a></h4><div id="rfc.section.1.2.3.p.1"><p>An important part of the HTTP/1.1 exchange is that the client is able to easily identify the request that caused the TLS renegotiation. The client is able to assume that the next unanswered request on the connection is responsible. The HTTP stack in the client is then able to direct the certificate request to the application or component that initiated that request. This ensures that the application has the right contextual information for processing the request.</p></div><div id="rfc.section.1.2.3.p.2"><p>In HTTP/2, a client can have multiple outstanding requests. Without some sort of correlation information, a client is unable to identify which request caused the server to request a certificate.</p></div><div id="rfc.section.1.2.3.p.3"><p>Thus, the minimum necessary mechanism to support reactive certificate authentication in HTTP/2 is an identifier that can be use to correlate an HTTP request with a request for a certificate. Since streams are used for individual requests, correlation with a stream is sufficient.</p></div><div id="rfc.section.1.2.3.p.4"><p><a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> prohibits renegotiation after any application data has been sent. This completely blocks reactive certificate authentication in HTTP/2 using TLS 1.2. If this restriction were relaxed by an extension or update to HTTP/2, such an identifier could be added to TLS 1.2 by means of an extension to TLS. Unfortunately, many TLS 1.2 implementations do not permit application data to continue during a renegotiation. This is problematic for a multiplexed protocol like HTTP/2.</p></div></section></section><section id="http-layer-certificate-authentication"><h3 id="rfc.section.1.3"><a href="#rfc.section.1.3">1.3.</a>&nbsp;<a href="#http-layer-certificate-authentication">HTTP-Layer Certificate Authentication</a></h3><div id="rfc.section.1.3.p.1"><p>This draft defines HTTP/2 frames to carry the relevant certificate messages, enabling certificate-based authentication of both clients and servers independent of TLS version. This mechanism can be implemented at the HTTP layer without breaking the existing interface between HTTP and applications above it.</p></div><div id="rfc.section.1.3.p.2"><p>This could be done in a naive manner by replicating the TLS messages as HTTP/2 frames on each stream. However, this would create needless redundancy between streams and require frequent expensive signing operations. Instead, TLS Exported Authenticators <a href="#I-D.ietf-tls-exported-authenticator"><cite title="Exported Authenticators in TLS">[I-D.ietf-tls-exported-authenticator]</cite></a> are exchanged on stream zero and the on-stream frames incorporate them by reference as needed.</p></div><div id="rfc.section.1.3.p.3"><p>TLS Exported Authenticators are structured messages that can be exported by either party of a TLS connection and validated by the other party. An authenticator message can be constructed by either the client or the server given an established TLS connection, a certificate, and a corresponding private key. Exported Authenticators use the message structures from section 4.4 of <a href="#I-D.ietf-tls-tls13"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[I-D.ietf-tls-tls13]</cite></a>, but different parameters.</p></div><div id="rfc.section.1.3.p.4"><p>Each Authenticator is computed using a Handshake Context and Finished MAC Key derived from the TLS session. The Handshake Context is identical for both parties of the TLS connection, while the Finished MAC Key is dependent on whether the Authenticator is created by the client or the server.</p></div><div id="rfc.section.1.3.p.5"><p>Successfully verified Authenticators result in certificate chains, with verified possession of the corresponding private key, which can be supplied into a collection of available certificates. Likewise, descriptions of desired certificates can be supplied into these collections. These pre-supplied elements are then available for automatic use (in some situations) or for reference by individual streams.</p></div><div id="rfc.section.1.3.p.6"><p><a href="#discovery" title="Discovering Additional Certificates at the HTTP/2 Layer">Section&nbsp;2</a> describes how the feature is employed, defining means to detect support in peers (<a href="#setting" title="Indicating support for HTTP-layer certificate authentication">Section&nbsp;2.1</a>), make certificates and requests available (<a href="#cert-available" title="Making certificates or requests available">Section&nbsp;2.2</a>), and indicate when streams are blocked waiting on an appropriate certificate (<a href="#cert-challenge" title="Requiring certificate authentication">Section&nbsp;2.3</a>). <a href="#certs-http2" title="Certificates Frames for HTTP/2">Section&nbsp;3</a> defines the required frame types, which parallel the TLS 1.3 message exchange. Finally, <a href="#errors" title="Indicating failures during HTTP-Layer Certificate Authentication">Section&nbsp;4</a> defines new error types which can be used to notify peers when the exchange has not been successful.</p></div></section><section id="terminology"><h3 id="rfc.section.1.4"><a href="#rfc.section.1.4">1.4.</a>&nbsp;<a href="#terminology">Terminology</a></h3><div id="rfc.section.1.4.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in BCP 14 <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a> <a href="#RFC8174"><cite title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">[RFC8174]</cite></a> when, and only when, they appear in all capitals, as shown here.</p></div></section></section><hr class="hidden-print"><section id="discovery"><h2 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#discovery">Discovering Additional Certificates at the HTTP/2 Layer</a></h2><div id="rfc.section.2.p.1"><p>A certificate chain with proof of possession of the private key corresponding to the end-entity certificate is sent as a single <span class="tt">CERTIFICATE</span> frame (see <a href="#http-cert" title="The CERTIFICATE Frame">Section&nbsp;3.4</a>) on stream zero. Once the holder of a certificate has sent the chain and proof, this certificate chain is cached by the recipient and available for future use. If the certificate is marked as <span class="tt">AUTOMATIC_USE</span>, the certificate may be used by the recipient to authorize any current or future request. Otherwise, the recipient requests the required certificate on each stream, but the previously-supplied certificates are available for reference without having to resend them.</p></div><div id="rfc.section.2.p.2"><p>Likewise, the details of a request are sent on stream zero and stored by the recipient. These details will be referenced by subsequent <span class="tt">CERTIFICATE_NEEDED</span> frames.</p></div><div id="rfc.section.2.p.3"><p>Data sent by each peer is correlated by the ID given in each frame. This ID is unrelated to values used by the other peer, even if each uses the same ID in certain cases.</p></div><section id="setting"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a>&nbsp;<a href="#setting">Indicating support for HTTP-layer certificate authentication</a></h3><div id="rfc.section.2.1.p.1"><p>Clients and servers that will accept requests for HTTP-layer certificate authentication indicate this using the HTTP/2 <span class="tt">SETTINGS_HTTP_CERT_AUTH</span> (0xSETTING-TBD) setting.</p></div><div id="rfc.section.2.1.p.2"><p>The initial value for the <span class="tt">SETTINGS_HTTP_CERT_AUTH</span> setting is 0, indicating that the peer does not support HTTP-layer certificate authentication. If a peer does support HTTP-layer certificate authentication, the value is 1.</p></div></section><section id="cert-available"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a>&nbsp;<a href="#cert-available">Making certificates or requests available</a></h3><div id="rfc.section.2.2.p.1"><p>When a peer has advertised support for HTTP-layer certificates as in <a href="#setting" title="Indicating support for HTTP-layer certificate authentication">Section&nbsp;2.1</a>, either party can supply additional certificates into the connection at any time. These certificates then become available for the peer to consider when deciding whether a connection is suitable to transport a particular request.</p></div><div id="rfc.section.2.2.p.2"><p>Available certificates which have the <span class="tt">AUTOMATIC_USE</span> flag set MAY be used by the recipient without further notice. This means that clients or servers which predict a certificate will be required could pre-supply the certificate without being asked. Regardless of whether <span class="tt">AUTOMATIC_USE</span> is set, these certificates are available for reference by future <span class="tt">USE_CERTIFICATE</span> frames.</p></div><div id="ex-http2-server-proactive"></div><div id="rfc.figure.3"><pre>
Client                                      Server
   &lt;-------- (stream 0) CERTIFICATE (AU flag) --
   ...
   -- (stream N) GET /from-new-origin ---------&gt;
   &lt;----------------------- (stream N) 200 OK --

</pre></div><p class="figure">Figure 3: Proactive Server Certificate</p><div id="ex-http2-client-proactive"></div><div id="rfc.figure.4"><pre>
Client                                      Server
   -- (stream 0) CERTIFICATE (AU flag) --------&gt;
   -- (streams 1,3) GET /protected ------------&gt;
   &lt;-------------------- (streams 1,3) 200 OK --

</pre></div><p class="figure">Figure 4: Proactive Client Certificate</p><div id="rfc.section.2.2.p.3"><p>Likewise, either party can supply a <span class="tt">CERTIFICATE_REQUEST</span> that outlines parameters of a certificate they might request in the future. It is important to note that this does not currently request such a certificate, but makes the contents of the request available for reference by a future <span class="tt">CERTIFICATE_NEEDED</span> frame.</p></div></section><section id="cert-challenge"><h3 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a>&nbsp;<a href="#cert-challenge">Requiring certificate authentication</a></h3><div id="rfc.section.2.3.p.1"><p>As defined in <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, when a client finds that a https:// origin (or Alternative Service <a href="#RFC7838"><cite title="HTTP Alternative Services">[RFC7838]</cite></a>) to which it needs to make a request has the same IP address as a server to which it is already connected, it MAY check whether the TLS certificate provided contains the new origin as well, and if so, reuse the connection.</p></div><div id="rfc.section.2.3.p.2"><p>If the TLS certificate does not contain the new origin, but the server has claimed support for that origin (with an ORIGIN frame, see <a href="#I-D.ietf-httpbis-origin-frame"><cite title="The ORIGIN HTTP/2 Frame">[I-D.ietf-httpbis-origin-frame]</cite></a>) and advertised support for HTTP-layer certificates (see <a href="#setting" title="Indicating support for HTTP-layer certificate authentication">Section&nbsp;2.1</a>), it MAY send a <span class="tt">CERTIFICATE_NEEDED</span> frame on the stream it will use to make the request. (If the request parameters have not already been made available using a <span class="tt">CERTIFICATE_REQUEST</span> frame, the client will need to send the <span class="tt">CERTIFICATE_REQUEST</span> in order to generate the <span class="tt">CERTIFICATE_NEEDED</span> frame.) The stream represents a pending request to that origin which is blocked until a valid certificate is processed.</p></div><div id="rfc.section.2.3.p.3"><p>The request is blocked until the server has responded with a <span class="tt">USE_CERTIFICATE</span> frame pointing to a certificate for that origin. If the certificate is already available, the server SHOULD immediately respond with the appropriate <span class="tt">USE_CERTIFICATE</span> frame. (If the certificate has not already been transmitted, the server will need to make the certificate available as described in <a href="#cert-available" title="Making certificates or requests available">Section&nbsp;2.2</a> before completing the exchange.)</p></div><div id="rfc.section.2.3.p.4"><p>If the server does not have the desired certificate, it MUST respond with an empty <span class="tt">USE_CERTIFICATE</span> frame. In this case, or if the server has not advertised support for HTTP-layer certificates, the client MUST NOT send any requests for resources in that origin on the current connection.</p></div><div id="ex-http2-server-requested"></div><div id="rfc.figure.5"><pre>
Client                                      Server
   &lt;----------------------- (stream 0) ORIGIN --
   -- (stream 0) CERTIFICATE_REQUEST ----------&gt;
   ...
   -- (stream N) CERTIFICATE_NEEDED -----------&gt;
   &lt;------------------ (stream 0) CERTIFICATE --
   &lt;-------------- (stream N) USE_CERTIFICATE --
   -- (stream N) GET /from-new-origin ---------&gt;
   &lt;----------------------- (stream N) 200 OK --

</pre></div><p class="figure">Figure 5: Client-Requested Certificate</p><div id="rfc.section.2.3.p.5"><p>Likewise, on each stream where certificate authentication is required, the server sends a <span class="tt">CERTIFICATE_NEEDED</span> frame, which the client answers with a <span class="tt">USE_CERTIFICATE</span> frame indicating the certificate to use. If the request parameters or the responding certificate are not already available, they will need to be sent as described in <a href="#cert-available" title="Making certificates or requests available">Section&nbsp;2.2</a> as part of this exchange.</p></div><div id="ex-http2-client-requested"></div><div id="rfc.figure.6"><pre>
Client                                      Server
   &lt;---------- (stream 0) CERTIFICATE_REQUEST --
   ...
   -- (stream N) GET /protected ---------------&gt;
   &lt;----------- (stream N) CERTIFICATE_NEEDED --
   -- (stream 0) CERTIFICATE ------------------&gt;
   -- (stream N) USE_CERTIFICATE --------------&gt;
   &lt;----------------------- (stream N) 200 OK --

</pre></div><p class="figure">Figure 6: Reactive Certificate Authentication</p><div id="rfc.section.2.3.p.6"><p>A server SHOULD provide certificates for an origin before pushing resources from it or supplying content referencing the origin. If a client receives a <span class="tt">PUSH_PROMISE</span> referencing an origin for which it has not yet received the server’s certificate, the client MUST verify the server’s possession of an appropriate certificate by sending a <span class="tt">CERTIFICATE_NEEDED</span> frame on the pushed stream to inform the server that progress is blocked until the request is satisfied. The client MUST NOT use the pushed resource until an appropriate certificate has been received and validated.</p></div></section></section><hr class="hidden-print"><section id="certs-http2"><h2 id="rfc.section.3" class="np"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#certs-http2">Certificates Frames for HTTP/2</a></h2><div id="rfc.section.3.p.1"><p>The <span class="tt">CERTIFICATE_REQUEST</span> and <span class="tt">CERTIFICATE_NEEDED</span> frames are correlated by their <span class="tt">Request-ID</span> field. Subsequent <span class="tt">CERTIFICATE_NEEDED</span> frames with the same <span class="tt">Request-ID</span> value MAY be sent on other streams where the sender is expecting a certificate with the same parameters.</p></div><div id="rfc.section.3.p.2"><p>The <span class="tt">CERTIFICATE</span>, and <span class="tt">USE_CERTIFICATE</span> frames are correlated by their <span class="tt">Cert-ID</span> field. Subsequent <span class="tt">USE_CERTIFICATE</span> frames with the same <span class="tt">Cert-ID</span> MAY be sent in response to other <span class="tt">CERTIFICATE_NEEDED</span> frames and refer to the same certificate.</p></div><div id="rfc.section.3.p.3"><p><span class="tt">Request-ID</span> and <span class="tt">Cert-ID</span> are sender-local, and the use of the same value by the other peer does not imply any correlation between their frames. These values MUST be unique per sender over the lifetime of the connection.</p></div><section id="http-cert-needed"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a>&nbsp;<a href="#http-cert-needed">The CERTIFICATE_NEEDED frame</a></h3><div id="rfc.section.3.1.p.1"><p>The <span class="tt">CERTIFICATE_NEEDED</span> frame (0xFRAME-TBD1) is sent to indicate that the HTTP request on the current stream is blocked pending certificate authentication. The frame includes a request identifier which can be used to correlate the stream with a previous <span class="tt">CERTIFICATE_REQUEST</span> frame sent on stream zero. The <span class="tt">CERTIFICATE_REQUEST</span> describes the certificate the sender requires to make progress on the stream in question.</p></div><div id="rfc.section.3.1.p.2"><p>The <span class="tt">CERTIFICATE_NEEDED</span> frame contains 2 octets, which is the authentication request identifier, <span class="tt">Request-ID</span>. A peer that receives a <span class="tt">CERTIFICATE_NEEDED</span> of any other length MUST treat this as a stream error of type <span class="tt">PROTOCOL_ERROR</span>. Frames with identical request identifiers refer to the same <span class="tt">CERTIFICATE_REQUEST</span>.</p></div><div id="rfc.section.3.1.p.3"><p>A server MAY send multiple <span class="tt">CERTIFICATE_NEEDED</span> frames on the same stream. If a server requires that a client provide multiple certificates before authorizing a single request, each required certificate MUST be indicated with a separate <span class="tt">CERTIFICATE_NEEDED</span> frame, each of which MUST have a different request identifier (referencing different <span class="tt">CERTIFICATE_REQUEST</span> frames describing each required certificate). To reduce the risk of client confusion, servers SHOULD NOT have multiple outstanding <span class="tt">CERTIFICATE_NEEDED</span> frames on the same stream at any given time.</p></div><div id="rfc.section.3.1.p.4"><p>Clients MUST NOT send multiple <span class="tt">CERTIFICATE_NEEDED</span> frames on the same stream.</p></div><div id="rfc.section.3.1.p.5"><p>The <span class="tt">CERTIFICATE_NEEDED</span> frame MUST NOT be sent to a peer which has not advertised support for HTTP-layer certificate authentication.</p></div><div id="rfc.section.3.1.p.6"><p>The <span class="tt">CERTIFICATE_NEEDED</span> frame MUST NOT be sent on stream zero, and MUST NOT be sent on a stream in the “half-closed (local)” state <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>. A client that receives a <span class="tt">CERTIFICATE_NEEDED</span> frame on a stream which is not in a valid state SHOULD treat this as a stream error of type <span class="tt">PROTOCOL_ERROR</span>.</p></div></section><section id="http-use-certificate"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a>&nbsp;<a href="#http-use-certificate">The USE_CERTIFICATE Frame</a></h3><div id="rfc.section.3.2.p.1"><p>The <span class="tt">USE_CERTIFICATE</span> frame (0xFRAME-TBD4) is sent in response to a <span class="tt">CERTIFICATE_NEEDED</span> frame to indicate which certificate is being used to satisfy the requirement.</p></div><div id="rfc.section.3.2.p.2"><p>A <span class="tt">USE_CERTIFICATE</span> frame with no payload refers to the certificate provided at the TLS layer, if any. If no certificate was provided at the TLS layer, the stream should be processed with no authentication, likely returning an authentication-related error at the HTTP level (e.g. 403) for servers or routing the request to a new connection for clients.</p></div><div id="rfc.section.3.2.p.3"><p>Otherwise, the <span class="tt">USE_CERTIFICATE</span> frame contains the two-octet <span class="tt">Cert-ID</span> of the certificate the sender wishes to use. This MUST be the ID of a certificate for which proof of possession has been presented in a <span class="tt">CERTIFICATE</span> frame. Recipients of a <span class="tt">USE_CERTIFICATE</span> frame of any other length MUST treat this as a stream error of type <span class="tt">PROTOCOL_ERROR</span>. Frames with identical certificate identifiers refer to the same certificate chain.</p></div><div id="rfc.section.3.2.p.4"><p>The <span class="tt">USE_CERTIFICATE</span> frame MUST NOT be sent on stream zero or a stream on which a <span class="tt">CERTIFICATE_NEEDED</span> frame has not been received. Receipt of a <span class="tt">USE_CERTIFICATE</span> frame in these circumstances SHOULD be treated as a stream error of type <span class="tt">PROTOCOL_ERROR</span>. Each <span class="tt">USE_CERTIFICATE</span> frame should reference a preceding <span class="tt">CERTIFICATE</span> frame. Receipt of a <span class="tt">USE_CERTIFICATE</span> frame before the necessary frames have been received on stream zero MUST also result in a stream error of type <span class="tt">PROTOCOL_ERROR</span>.</p></div><div id="rfc.section.3.2.p.5"><p>The referenced certificate chain MUST conform to the requirements expressed in the <span class="tt">CERTIFICATE_REQUEST</span> to the best of the sender’s ability. Specifically, if the <span class="tt">CERTIFICATE_REQUEST</span> contained a non-empty <span class="tt">Cert-Extensions</span> element, the end-entity certificate MUST match with regard to the extensions recognized by the sender.</p></div><div id="rfc.section.3.2.p.6"><p>If these requirements are not satisfied, the recipient MAY at its discretion either return an error at the HTTP semantic layer, or respond with a stream error <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> on any stream where the certificate is used. <a href="#errors" title="Indicating failures during HTTP-Layer Certificate Authentication">Section&nbsp;4</a> defines certificate-related error codes which might be applicable.</p></div></section><section id="http-cert-request"><h3 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a>&nbsp;<a href="#http-cert-request">The CERTIFICATE_REQUEST Frame</a></h3><div id="rfc.section.3.3.p.1"><p>TLS 1.3 defines the <span class="tt">CertificateRequest</span> message, which prompts the client to provide a certificate which conforms to certain properties specified by the server. This draft defines the <span class="tt">CERTIFICATE_REQUEST</span> frame (0xFRAME-TBD2), which uses the same set of extensions to specify a desired certificate, but can be sent over any TLS version and can be sent by either peer.</p></div><div id="rfc.section.3.3.p.2"><p>The <span class="tt">CERTIFICATE_REQUEST</span> frame SHOULD NOT be sent to a peer which has not advertised support for HTTP-layer certificate authentication.</p></div><div id="rfc.section.3.3.p.3"><p>The <span class="tt">CERTIFICATE_REQUEST</span> frame MUST be sent on stream zero. A <span class="tt">CERTIFICATE_REQUEST</span> frame received on any other stream MUST be rejected with a stream error of type <span class="tt">PROTOCOL_ERROR</span>.</p></div><div id="fig-cert-request"></div><div id="rfc.figure.7"><pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 |        Request-ID (16)        |      Extension-Count (16)     |
 +-------------------------------+-------------------------------+
 |                          Extensions(?)                      ...
 +---------------------------------------------------------------+
</pre></div><p class="figure">Figure 7: CERTIFICATE_REQUEST frame payload</p><div id="rfc.section.3.3.p.4" class="avoidbreakafter"><p>The frame contains the following fields:</p></div><div id="rfc.section.3.3.p.5"><dl><dt>Request-ID:</dt><dd><span class="tt">Request-ID</span> is a 16-bit opaque identifier used to correlate subsequent certificate-related frames with this request. The identifier MUST be unique in the session for the sender.</dd><dt>Extension-Count and Extensions:</dt><dd>A list of certificate selection criteria, represented in a series of <span class="tt">Extension</span> structures (see <a href="#I-D.ietf-tls-tls13"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[I-D.ietf-tls-tls13]</cite></a> section 4.2). This criteria MUST be used in certificate selection as described in <a href="#I-D.ietf-tls-tls13"><cite title="The Transport Layer Security (TLS) Protocol Version 1.3">[I-D.ietf-tls-tls13]</cite></a>. The number of <span class="tt">Extension</span> structures is given by the 16-bit <span class="tt">Extension-Count</span> field, which MAY be zero.</dd></dl></div><div id="rfc.section.3.3.p.6"><p>Some extensions used for certificate selection allow multiple values (e.g. oid_filters on Extended Key Usage). If the sender has included a non-empty Extensions list, the certificate MUST match all criteria specified by extensions the recipient recognizes. However, the recipient MUST ignore and skip any unrecognized certificate selection extensions.</p></div><div id="rfc.section.3.3.p.7"><p>Servers MUST be able to recognize the <span class="tt">server_name</span> extension (<a href="#RFC6066"><cite title="Transport Layer Security (TLS) Extensions: Extension Definitions">[RFC6066]</cite></a>) at a minimum. Clients MUST always specify the desired origin using this extension, though other extensions MAY also be included.</p></div></section><section id="http-cert"><h3 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a>&nbsp;<a href="#http-cert">The CERTIFICATE Frame</a></h3><div id="rfc.section.3.4.p.1"><p>The <span class="tt">CERTIFICATE</span> frame (id=0xFRAME-TBD3) provides a exported authenticator message from the TLS layer that provides a chain of certificates, associated extensions and proves possession of the private key corresponding to the end-entity certificate.</p></div><div id="rfc.section.3.4.p.2" class="avoidbreakafter"><p>The <span class="tt">CERTIFICATE</span> frame defines two flags:</p></div><div id="rfc.section.3.4.p.3"><dl><dt>AUTOMATIC_USE (0x01):</dt><dd>Indicates that the certificate can be used automatically on future requests.</dd><dt>TO_BE_CONTINUED (0x02):</dt><dd>Indicates that the exported authenticator spans more than one frame.</dd></dl></div><div id="fig-proof-frame"></div><div id="rfc.figure.8"><pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 |          Cert-ID (16)         |   Authenticator Fragment (*)...
 +---------------------------------------------------------------+
</pre></div><p class="figure">Figure 8: CERTIFICATE frame payload</p><div id="rfc.section.3.4.p.4"><p>The <span class="tt">Exported Authenticator Fragment</span> field contains a portion of the opaque data returned from the TLS connection exported authenticator <span class="tt">authenticate</span> API. See <a href="#exp-auth" title="Exported Authenticator Characteristics">Section&nbsp;3.4.1</a> for more details on the input to this API.</p></div><div id="rfc.section.3.4.p.5"><p>This opaque data is transported in zero or more <span class="tt">CERTIFICATE</span> frames with the <span class="tt">TO_BE_CONTINUED</span> flag set, followed by one <span class="tt">CERTIFICATE</span> frame with the <span class="tt">TO_BE_CONTINUED</span> flag unset. Each of these frames contains the same <span class="tt">Cert-ID</span> field, permitting them to be associated with each other. Receipt of any <span class="tt">CERTIFICATE</span> frame with the same <span class="tt">Cert-ID</span> following the receipt of a <span class="tt">CERTIFICATE</span> frame with <span class="tt">TO_BE_CONTINUED</span> unset MUST be treated as a connection error of type <span class="tt">PROTOCOL_ERROR</span>.</p></div><div id="rfc.section.3.4.p.6"><p>If the <span class="tt">AUTOMATIC_USE</span> flag is set, the recipient MAY omit sending <span class="tt">CERTIFICATE_NEEDED</span> frames on future streams which would require a similar certificate and use the referenced certificate for authentication without further notice to the holder. This behavior is optional, and receipt of a <span class="tt">CERTIFICATE_NEEDED</span> frame does not imply that previously-presented certificates were unacceptable, even if <span class="tt">AUTOMATIC_USE</span> was set. Servers MUST set the <span class="tt">AUTOMATIC_USE</span> flag when sending a <span class="tt">CERTIFICATE</span> frame. A server MUST NOT send certificates for origins which it is not prepared to service on the current connection.</p></div><div id="rfc.section.3.4.p.7"><p>Upon receiving a complete series of <span class="tt">CERTIFICATE</span> frames, the receiver may validate the Exported Authenticator value by using the exported authenticator API. This returns either an error indicating that the message was invalid, or the certificate chain and extensions used to create the message.</p></div><div id="rfc.section.3.4.p.8"><p>The <span class="tt">CERTIFICATE</span> frame MUST be sent on stream zero. A <span class="tt">CERTIFICATE</span> frame received on any other stream MUST be rejected with a stream error of type <span class="tt">PROTOCOL_ERROR</span>.</p></div><section id="exp-auth"><h4 id="rfc.section.3.4.1"><a href="#rfc.section.3.4.1">3.4.1.</a>&nbsp;<a href="#exp-auth">Exported Authenticator Characteristics</a></h4><div id="rfc.section.3.4.1.p.1"><p>The Exported Authenticator API defined in <a href="#I-D.ietf-tls-exported-authenticator"><cite title="Exported Authenticators in TLS">[I-D.ietf-tls-exported-authenticator]</cite></a> takes as input a certificate, supporting information about the certificate (OCSP, SCT, etc.), and an optional <span class="tt">certificate_request_context</span>. When generating exported authenticators for use with this extension, the <span class="tt">certificate_request_context</span> MUST be the two-octet Cert-ID.</p></div><div id="rfc.section.3.4.1.p.2" class="avoidbreakafter"><p>Upon receipt of a completed authenticator, an endpoint MUST check that:</p></div><div id="rfc.section.3.4.1.p.3"><ul><li>the <span class="tt">validate</span> API confirms the validity of the authenticator itself</li><li>the <span class="tt">certificate_request_context</span> matches the Cert-ID of the frame(s) in which it was received</li></ul></div><div id="rfc.section.3.4.1.p.4"><p>Once the authenticator is accepted, the endpoint can perform any other checks for the acceptability of the certificate itself.</p></div></section></section></section><hr class="hidden-print"><section id="errors"><h2 id="rfc.section.4" class="np"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#errors">Indicating failures during HTTP-Layer Certificate Authentication</a></h2><div id="rfc.section.4.p.1"><p>Because this draft permits certificates to be exchanged at the HTTP framing layer instead of the TLS layer, several certificate-related errors which are defined at the TLS layer might now occur at the HTTP framing layer. In this section, those errors are restated and added to the HTTP/2 error code registry.</p></div><div id="rfc.section.4.p.2"><dl><dt>BAD_CERTIFICATE (0xERROR-TBD1):</dt><dd>A certificate was corrupt, contained signatures that did not verify correctly, etc.</dd><dt>UNSUPPORTED_CERTIFICATE (0xERROR-TBD2):</dt><dd>A certificate was of an unsupported type or did not contain required extensions</dd><dt>CERTIFICATE_REVOKED (0xERROR-TBD3):</dt><dd>A certificate was revoked by its signer</dd><dt>CERTIFICATE_EXPIRED (0xERROR-TBD4):</dt><dd>A certificate has expired or is not currently valid</dd><dt>CERTIFICATE_GENERAL (0xERROR-TBD5):</dt><dd>Any other certificate-related error</dd></dl></div><div id="rfc.section.4.p.3"><p>As described in <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, implementations MAY choose to treat a stream error as a connection error at any time. Of particular note, a stream error cannot occur on stream 0, which means that implementations cannot send non-session errors in response to <span class="tt">CERTIFICATE_REQUEST</span>, and <span class="tt">CERTIFICATE</span> frames. Implementations which do not wish to terminate the connection MAY either send relevant errors on any stream which references the failing certificate in question or process the requests as unauthenticated and provide error information at the HTTP semantic layer.</p></div></section><hr class="hidden-print"><section id="security"><h2 id="rfc.section.5" class="np"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#security">Security Considerations</a></h2><div id="rfc.section.5.p.1"><p>This mechanism defines an alternate way to obtain server and client certificates other than in the initial TLS handshake. While the signature of exported authenticator values is expected to be equally secure, it is important to recognize that a vulnerability in this code path is at least equal to a vulnerability in the TLS handshake.</p></div><section id="impersonation"><h3 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a>&nbsp;<a href="#impersonation">Impersonation</a></h3><div id="rfc.section.5.1.p.1"><p>This mechanism could increase the impact of a key compromise. Rather than needing to subvert DNS or IP routing in order to use a compromised certificate, a malicious server now only needs a client to connect to <em>some</em> HTTPS site under its control in order to present the compromised certificate. As recommended in <a href="#I-D.ietf-httpbis-origin-frame"><cite title="The ORIGIN HTTP/2 Frame">[I-D.ietf-httpbis-origin-frame]</cite></a>, clients opting not to consult DNS ought to employ some alternative means to increase confidence that the certificate is legitimate.</p></div><div id="rfc.section.5.1.p.2"><p>As noted in the Security Considerations of <a href="#I-D.ietf-tls-exported-authenticator"><cite title="Exported Authenticators in TLS">[I-D.ietf-tls-exported-authenticator]</cite></a>, it difficult to formally prove that an endpoint is jointly authoritative over multiple certificates, rather than individually authoritative on each certificate. As a result, clients MUST NOT assume that because one origin was previously colocated with another, those origins will be reachable via the same endpoints in the future. Clients MUST NOT consider previous secondary certificates to be validated after TLS session resumption. However, clients MAY proactively query for previously-presented secondary certificates.</p></div></section><section id="fingerprinting"><h3 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a>&nbsp;<a href="#fingerprinting">Fingerprinting</a></h3><div id="rfc.section.5.2.p.1"><p>This draft defines a mechanism which could be used to probe servers for origins they support, but opens no new attack versus making repeat TLS connections with different SNI values. Servers SHOULD impose similar denial-of-service mitigations (e.g. request rate limits) to <span class="tt">CERTIFICATE_REQUEST</span> frames as to new TLS connections.</p></div><div id="rfc.section.5.2.p.2"><p>While the extensions in the <span class="tt">CERTIFICATE_REQUEST</span> frame permit the sender to enumerate the acceptable Certificate Authorities for the requested certificate, it might not be prudent (either for security or data consumption) to include the full list of trusted Certificate Authorities in every request. Senders, particularly clients, SHOULD send only the extensions that narrowly specify which certificates would be acceptable.</p></div></section><section id="denial-of-service"><h3 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a>&nbsp;<a href="#denial-of-service">Denial of Service</a></h3><div id="rfc.section.5.3.p.1"><p>Failure to provide a certificate on a stream after receiving <span class="tt">CERTIFICATE_NEEDED</span> blocks processing, and SHOULD be subject to standard timeouts used to guard against unresponsive peers.</p></div><div id="rfc.section.5.3.p.2"><p>Validating a multitude of signatures can be computationally expensive, while generating an invalid signature is computationally cheap. Implementations will require checks for attacks from this direction. Invalid exported authenticators SHOULD be treated as a session error, to avoid further attacks from the peer, though an implementation MAY instead disable HTTP-layer certificates for the current connection instead.</p></div></section><section id="confusion-about-state"><h3 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a>&nbsp;<a href="#confusion-about-state">Confusion About State</a></h3><div id="rfc.section.5.4.p.1"><p>Implementations need to be aware of the potential for confusion about the state of a connection. The presence or absence of a validated certificate can change during the processing of a request, potentially multiple times, as <span class="tt">USE_CERTIFICATE</span> frames are received. A server that uses certificate authentication needs to be prepared to reevaluate the authorization state of a request as the set of certificates changes.</p></div><div id="rfc.section.5.4.p.2"><p>Client implementations need to carefully consider the impact of setting the <span class="tt">AUTOMATIC_USE</span> flag. This flag is a performance optimization, permitting the client to avoid a round-trip on each request where the server checks for certificate authentication. However, once this flag has been sent, the client has zero knowledge about whether the server will use the referenced cert for any future request, or even for an existing request which has not yet completed. Clients MUST NOT set this flag on any certificate which is not appropriate for currently-in-flight requests, and MUST NOT make any future requests on the same connection which they are not willing to have associated with the provided certificate.</p></div></section></section><hr class="hidden-print"><section id="iana"><h2 id="rfc.section.6" class="np"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#iana">IANA Considerations</a></h2><div id="rfc.section.6.p.1"><p>This draft adds entries in three registries.</p></div><div id="rfc.section.6.p.2"><p>The HTTP/2 <span class="tt">SETTINGS_HTTP_CERT_AUTH</span> setting is registered in <a href="#iana-setting" title="HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting">Section&nbsp;6.1</a>. Four frame types are registered in <a href="#iana-frame" title="New HTTP/2 Frames">Section&nbsp;6.2</a>. Six error codes are registered in <a href="#iana-errors" title="New HTTP/2 Error Codes">Section&nbsp;6.3</a>.</p></div><section id="iana-setting"><h3 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a>&nbsp;<a href="#iana-setting">HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting</a></h3><div id="rfc.section.6.1.p.1"><p>The SETTINGS_HTTP_CERT_AUTH setting is registered in the “HTTP/2 Settings” registry established in <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>.</p></div><div id="rfc.section.6.1.p.2"><dl><dt>Name:</dt><dd>SETTINGS_HTTP_CERT_AUTH</dd><dt>Code:</dt><dd>0xSETTING-TBD</dd><dt>Initial Value:</dt><dd>0</dd><dt>Specification:</dt><dd>This document.</dd></dl></div></section><section id="iana-frame"><h3 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a>&nbsp;<a href="#iana-frame">New HTTP/2 Frames</a></h3><div id="rfc.section.6.2.p.1"><p>Four new frame types are registered in the “HTTP/2 Frame Types” registry established in <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>. The entries in the following table are registered by this document.</p></div><div id="rfc.table.u.1" class="table table-condensed table-striped"><table class="table table-condensed table-striped full text-center"><thead><tr><th class="left">Frame Type</th><th class="left">Code</th><th class="left">Specification</th></tr></thead><tbody><tr><td class="text-left">CERTIFICATE_NEEDED</td><td class="text-left">0xFRAME-TBD1</td><td class="text-left"><a href="#http-cert-needed" title="The CERTIFICATE_NEEDED frame">Section&nbsp;3.1</a></td></tr><tr><td class="text-left">CERTIFICATE_REQUEST</td><td class="text-left">0xFRAME-TBD2</td><td class="text-left"><a href="#http-cert-request" title="The CERTIFICATE_REQUEST Frame">Section&nbsp;3.3</a></td></tr><tr><td class="text-left">CERTIFICATE</td><td class="text-left">0xFRAME-TBD3</td><td class="text-left"><a href="#http-cert" title="The CERTIFICATE Frame">Section&nbsp;3.4</a></td></tr><tr><td class="text-left">USE_CERTIFICATE</td><td class="text-left">0xFRAME-TBD4</td><td class="text-left"><a href="#http-use-certificate" title="The USE_CERTIFICATE Frame">Section&nbsp;3.2</a></td></tr></tbody></table></div></section><section id="iana-errors"><h3 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a>&nbsp;<a href="#iana-errors">New HTTP/2 Error Codes</a></h3><div id="rfc.section.6.3.p.1"><p>Five new error codes are registered in the “HTTP/2 Error Code” registry established in <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>. The entries in the following table are registered by this document.</p></div><div id="rfc.table.u.2" class="table table-condensed table-striped"><table class="table table-condensed table-striped full text-center"><thead><tr><th class="left">Name</th><th class="left">Code</th><th class="left">Specification</th></tr></thead><tbody><tr><td class="text-left">BAD_CERTIFICATE</td><td class="text-left">0xERROR-TBD1</td><td class="text-left"><a href="#errors" title="Indicating failures during HTTP-Layer Certificate Authentication">Section&nbsp;4</a></td></tr><tr><td class="text-left">UNSUPPORTED_CERTIFICATE</td><td class="text-left">0xERROR-TBD2</td><td class="text-left"><a href="#errors" title="Indicating failures during HTTP-Layer Certificate Authentication">Section&nbsp;4</a></td></tr><tr><td class="text-left">CERTIFICATE_REVOKED</td><td class="text-left">0xERROR-TBD3</td><td class="text-left"><a href="#errors" title="Indicating failures during HTTP-Layer Certificate Authentication">Section&nbsp;4</a></td></tr><tr><td class="text-left">CERTIFICATE_EXPIRED</td><td class="text-left">0xERROR-TBD4</td><td class="text-left"><a href="#errors" title="Indicating failures during HTTP-Layer Certificate Authentication">Section&nbsp;4</a></td></tr><tr><td class="text-left">CERTIFICATE_GENERAL</td><td class="text-left">0xERROR-TBD5</td><td class="text-left"><a href="#errors" title="Indicating failures during HTTP-Layer Certificate Authentication">Section&nbsp;4</a></td></tr></tbody></table></div></section></section><hr class="hidden-print"><section id="ack"><h2 id="rfc.section.7" class="np"><a href="#rfc.section.7">7.</a>&nbsp;<a href="#ack">Acknowledgements</a></h2><div id="rfc.section.7.p.1"><p>Eric Rescorla pointed out several failings in an earlier revision. Andrei Popov contributed to the TLS considerations.</p></div><div id="rfc.section.7.p.2"><p>A substantial portion of Mike’s work on this draft was supported by Microsoft during his employment there.</p></div></section><hr class="hidden-print"><section id="rfc.references" class="np"><h2 id="rfc.section.8"><a href="#rfc.section.8">8.</a> References</h2><section id="rfc.references.1" class="np"><h3 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a> Normative References</h3><dl class="dl-horizontal"><dt id="I-D.ietf-tls-exported-authenticator">[I-D.ietf-tls-exported-authenticator]</dt><dd>Sullivan, N., “<a href="https://tools.ietf.org/html/draft-ietf-tls-exported-authenticator-04">Exported Authenticators in TLS</a>”, Internet-Draft&nbsp;draft-ietf-tls-exported-authenticator-04 (work in progress), October&nbsp;2017.</dd><dt id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</dt><dd>Rescorla, E., “<a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-22">The Transport Layer Security (TLS) Protocol Version 1.3</a>”, Internet-Draft&nbsp;draft-ietf-tls-tls13-22 (work in progress), November&nbsp;2017.</dd><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC5246">[RFC5246]</dt><dd>Dierks, T. and E. Rescorla, “<a href="https://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>”, RFC&nbsp;5246, <a href="http://dx.doi.org/10.17487/RFC5246">DOI&nbsp;10.17487/RFC5246</a>, August&nbsp;2008, &lt;<a href="https://www.rfc-editor.org/info/rfc5246">https://www.rfc-editor.org/info/rfc5246</a>&gt;.</dd><dt id="RFC6066">[RFC6066]</dt><dd>Eastlake 3rd, D., “<a href="https://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>”, RFC&nbsp;6066, <a href="http://dx.doi.org/10.17487/RFC6066">DOI&nbsp;10.17487/RFC6066</a>, January&nbsp;2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6066">https://www.rfc-editor.org/info/rfc6066</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC&nbsp;7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI&nbsp;10.17487/RFC7230</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC&nbsp;7540, <a href="http://dx.doi.org/10.17487/RFC7540">DOI&nbsp;10.17487/RFC7540</a>, May&nbsp;2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7540">https://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd><dt id="RFC8174">[RFC8174]</dt><dd>Leiba, B., “<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>”, BCP&nbsp;14, RFC&nbsp;8174, <a href="http://dx.doi.org/10.17487/RFC8174">DOI&nbsp;10.17487/RFC8174</a>, May&nbsp;2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.</dd></dl></section><section id="rfc.references.2"><h3 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2.</a> Informative References</h3><dl class="dl-horizontal"><dt id="I-D.ietf-httpbis-origin-frame">[I-D.ietf-httpbis-origin-frame]</dt><dd>Nottingham, M. and E. Nygren, “<a href="https://tools.ietf.org/html/draft-ietf-httpbis-origin-frame-04">The ORIGIN HTTP/2 Frame</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-origin-frame-04 (work in progress), August&nbsp;2017.</dd><dt id="RFC7838">[RFC7838]</dt><dd>Nottingham, M., McManus, P., and J. Reschke, “<a href="https://tools.ietf.org/html/rfc7838">HTTP Alternative Services</a>”, RFC&nbsp;7838, <a href="http://dx.doi.org/10.17487/RFC7838">DOI&nbsp;10.17487/RFC7838</a>, April&nbsp;2016, &lt;<a href="https://www.rfc-editor.org/info/rfc7838">https://www.rfc-editor.org/info/rfc7838</a>&gt;.</dd></dl></section></section><hr class="hidden-print"><section id="rfc.authors" class="np"><h2><a href="#rfc.authors">Authors' Addresses</a></h2><address><b>Mike Bishop</b><br>Akamai<br>EMail: <a href="mailto:mbishop@evequefou.be">mbishop@evequefou.be</a></address><address><b>Nick Sullivan</b><br>Cloudflare<br>EMail: <a href="mailto:nick@cloudflare.com">nick@cloudflare.com</a></address><address><b>Martin Thomson</b><br>Mozilla<br>EMail: <a href="mailto:martin.thomson@gmail.com">martin.thomson@gmail.com</a></address></section></div></div></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script></body></html>